<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Face Catch</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1A202C;
            color: #E2E8F0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; 
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding-bottom: 1rem; 
        }
        #canvasContainer {
            position: relative;
            background-color: #0d1117; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 0.25rem;
        }
        #gameCanvas {
            display: block;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
            width: 100%; 
            height: 100%; 
        }
        .modal-content {
            background-color: #2d3748 !important; 
            color: #E2E8F0 !important;
            border: 1px solid #4a5568;
        }
        .modal-header, .modal-footer {
            border-color: #4a5568 !important;
        }
        .btn-primary {
            background-color: #0D6EFD; 
            border-color: #0D6EFD;
        }
        .btn-primary:hover {
            background-color: #0B5ED7;
            border-color: #0A58CA;
        }
        .btn-info {
            background-color: #0DCAF0; 
            border-color: #0DCAF0;
            color: #000;
        }
        .btn-info:hover {
            background-color: #31D2F2;
            border-color: #25CFF2;
             color: #000;
        }
        .btn-warning {
             background-color: #FFC107; 
             border-color: #FFC107;
             color: #000;
        }
         .btn-warning:hover {
             background-color: #FFCA2C;
             border-color: #FFC720;
             color: #000;
         }
        .stat-value {
            font-weight: bold;
            color: #FFC107; 
        }
        #pauseScreen {
            z-index: 20;
            font-size: 2rem;
            text-shadow: 2px 2px 4px #000;
        }
        .img-icon {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 32, 44, 0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #E2E8F0;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="spinner-border text-primary mb-3" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p>Loading Game Assets...</p>
    </div>

    <div id="game-wrapper" class="container-fluid text-center p-0">
        <h1 id="gameTitle" class="my-2 my-md-3 display-5 text-white">Happy Face Catch</h1>

        <div id="statsBar" class="row justify-content-around mb-2 text-white fs-5 w-100 px-1">
            <div class="col-auto">Score: <span id="scoreDisplay" class="stat-value">0</span></div>
            <div class="col-auto">Lives: <span id="livesDisplay" class="stat-value">3</span></div>
            <div class="col-auto">High Score: <span id="highScoreDisplay" class="stat-value">0</span></div>
            <div class="col-auto" id="comboDisplayArea" style="visibility: hidden;">Combo: <span id="comboMultiplierDisplay" class="stat-value">x1.0</span></div>
        </div>

        <div id="canvasContainer" class="mx-auto position-relative">
            <canvas id="gameCanvas"></canvas>
            <button id="pauseButton" class="btn btn-sm btn-warning position-absolute top-0 end-0 m-2" style="z-index: 10;">Pause</button>
            <button id="muteButton" class="btn btn-sm btn-info position-absolute top-0 start-0 m-2" style="z-index: 10;">Mute</button>
        </div>
    </div>

    <div class="modal fade" id="mainMenuModal" tabindex="-1" aria-labelledby="mainMenuModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="mainMenuModalLabel">Happy Face Catch</h5>
                </div>
                <div class="modal-body text-center">
                    <p>Welcome! Catch the happy faces and avoid the grumpy ones!</p>
                    <img src="/generated_images/dalle_0770ee4e-c6a.png" alt="Happy Face" class="img-fluid w-25 mb-3">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-info" id="instructionsButton">Instructions</button>
                    <button type="button" class="btn btn-primary" id="startGameButton" disabled>Start Game</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="instructionsModalLabel">Instructions</h5>
                </div>
                <div class="modal-body">
                    <p><strong>Controls:</strong></p>
                    <ul>
                        <li><strong>Keyboard:</strong> Use Left/Right Arrow keys to move the catcher.</li>
                        <li><strong>Mouse:</strong> Move your mouse horizontally to control the catcher.</li>
                        <li><strong>Touch:</strong> Drag horizontally on the screen.</li>
                    </ul>
                    <p><strong>Objective:</strong></p>
                    <ul>
                        <li>Catch <img src="/generated_images/dalle_0770ee4e-c6a.png" alt="Happy Face" class="img-icon"> Happy Faces for points!</li>
                        <li>Avoid <img src="/generated_images/dalle_67090d0c-5a8.png" alt="Grumpy Face" class="img-icon"> Grumpy Faces! Catching them costs a life.</li>
                        <li>Letting Happy Faces drop also costs a life.</li>
                        <li>Collect <img src="/generated_images/dalle_9f75f255-8f6.png" alt="Power Up" class="img-icon"> Power-Ups for bonuses!</li>
                        <li>Press 'P' or the Pause button to pause/resume.</li>
                        <li>Press 'M' or the Mute button to toggle sound.</li>
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="backToMenuButton">Back to Menu</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="gameOverModal" tabindex="-1" aria-labelledby="gameOverModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="gameOverModalLabel">Game Over!</h5>
                </div>
                <div class="modal-body text-center">
                    <p>Your final score: <strong id="finalScoreDisplay" class="stat-value fs-4">0</strong></p>
                    <p>High Score: <strong id="gameOverHighScoreDisplay" class="stat-value fs-4">0</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" id="playAgainButton">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="pauseScreen" class="position-absolute top-50 start-50 translate-middle bg-dark bg-opacity-75 p-4 rounded text-white d-none">
        Paused
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        (function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvasContainer');

            const GAME_CONFIG = {
                NATIVE_WIDTH: 800,
                NATIVE_HEIGHT: 600,
                PLAYER_WIDTH: 100,
                PLAYER_HEIGHT: 25, 
                PLAYER_SPEED: 500, 
                ITEM_SIZE: 40,
                INITIAL_FALL_SPEED: 100,
                MAX_FALL_SPEED: 400,
                SPEED_INCREASE_INTERVAL: 250, 
                SPEED_INCREASE_AMOUNT: 10,
                ITEM_SPAWN_INTERVAL_MIN: 700, 
                ITEM_SPAWN_INTERVAL_MAX: 1800, 
                INITIAL_LIVES: 3,
                POINTS_HAPPY: 10,
                POINTS_POWERUP: 50,
                COMBO_BONUS_MULTIPLIER: 0.1, 
                POWERUP_DURATION: 5000, 
                PARTICLE_COUNT: 20,
                PARTICLE_LIFESPAN: 1000,
                STAR_COUNT: 50,
                STAR_MIN_SPEED: 10,
                STAR_MAX_SPEED: 30,
            };

            let gameState = {
                score: 0,
                lives: GAME_CONFIG.INITIAL_LIVES,
                highScore: 0,
                currentPhase: 'LOADING', 
                isPaused: false,
                isMuted: false,
                lastTime: 0,
                itemSpawnTimer: 0,
                nextSpawnInterval: 0,
                currentFallSpeed: GAME_CONFIG.INITIAL_FALL_SPEED,
                nextSpeedIncreaseScoreThreshold: GAME_CONFIG.SPEED_INCREASE_INTERVAL,
                comboCount: 0,
                activePowerUp: null, 
                powerUpTimer: 0,
                backgroundStars: [],
            };

            let player, fallingItems, particles;
            let images = {};
            let sounds = {};

            const mainMenuModalEl = document.getElementById('mainMenuModal');
            const instructionsModalEl = document.getElementById('instructionsModal');
            const gameOverModalEl = document.getElementById('gameOverModal');
            let mainMenuModal, instructionsModal, gameOverModal; 

            const scoreDisplay = document.getElementById('scoreDisplay');
            const livesDisplay = document.getElementById('livesDisplay');
            const highScoreDisplay = document.getElementById('highScoreDisplay');
            const comboDisplayArea = document.getElementById('comboDisplayArea');
            const comboMultiplierDisplay = document.getElementById('comboMultiplierDisplay');
            const finalScoreDisplay = document.getElementById('finalScoreDisplay');
            const gameOverHighScoreDisplay = document.getElementById('gameOverHighScoreDisplay');
            const pauseButton = document.getElementById('pauseButton');
            const muteButton = document.getElementById('muteButton');
            const startGameButton = document.getElementById('startGameButton');
            const instructionsButton = document.getElementById('instructionsButton');
            const backToMenuButton = document.getElementById('backToMenuButton');
            const playAgainButton = document.getElementById('playAgainButton');
            const pauseScreen = document.getElementById('pauseScreen');
            const loadingScreen = document.getElementById('loadingScreen');

            class Player {
                constructor(x, y, width, height, image) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.image = image;
                    this.speed = GAME_CONFIG.PLAYER_SPEED;
                }

                update(dt, inputState) {
                    if (inputState.left) {
                        this.x -= this.speed * dt;
                    }
                    if (inputState.right) {
                        this.x += this.speed * dt;
                    }
                    if (inputState.mouseX !== null) {
                        this.x = inputState.mouseX - this.width / 2;
                    }
                    this.x = Math.max(0, Math.min(this.x, GAME_CONFIG.NATIVE_WIDTH - this.width));
                }

                draw(ctx) {
                    if (this.image && this.image.complete) {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    } else {
                        ctx.fillStyle = '#0D6EFD';
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }
                getHitbox() {
                    return { x: this.x, y: this.y, width: this.width, height: this.height };
                }
            }

            class FallingItem {
                constructor(x, y, size, image, type, speed, points) {
                    this.x = x;
                    this.y = y;
                    this.width = size;
                    this.height = size;
                    this.image = image;
                    this.type = type; 
                    this.speed = speed;
                    this.points = points;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * Math.PI / 2; 
                }

                update(dt) {
                    this.y += this.speed * dt;
                    this.rotation += this.rotationSpeed * dt;
                }

                draw(ctx) {
                    if (this.image && this.image.complete) {
                        ctx.save();
                        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                        ctx.rotate(this.rotation);
                        ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.restore();
                    } else {
                        ctx.fillStyle = this.type === 'happy' ? 'yellow' : (this.type === 'grumpy' ? 'red' : 'purple');
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }
                getHitbox() {
                    return { x: this.x, y: this.y, width: this.width, height: this.height };
                }
            }
            
            class Particle {
                constructor(x, y, color, size, lifespan) {
                    this.x = x;
                    this.y = y;
                    this.size = Math.random() * size + 2;
                    this.color = color;
                    this.lifespan = Math.random() * lifespan;
                    this.initialLifespan = this.lifespan;
                    this.vx = (Math.random() - 0.5) * 100;
                    this.vy = (Math.random() - 0.5) * 100 - 50; 
                    this.gravity = 150; 
                }

                update(dt) {
                    this.x += this.vx * dt;
                    this.vy += this.gravity * dt;
                    this.y += this.vy * dt;
                    this.lifespan -= dt * 1000;
                }

                draw(ctx) {
                    const alpha = Math.max(0, this.lifespan / this.initialLifespan);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }

            class Star {
                constructor(x, y, radius, speed, color) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.speed = speed;
                    this.color = color;
                }

                update(dt) {
                    this.y += this.speed * dt;
                    if (this.y - this.radius > GAME_CONFIG.NATIVE_HEIGHT) {
                        this.y = -this.radius * 2; 
                        this.x = Math.random() * GAME_CONFIG.NATIVE_WIDTH;
                        this.speed = Math.random() * (GAME_CONFIG.STAR_MAX_SPEED - GAME_CONFIG.STAR_MIN_SPEED) + GAME_CONFIG.STAR_MIN_SPEED;
                        this.radius = Math.random() * 1.5 + 0.5;
                    }
                }

                draw(ctx) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }


            function createParticleEffect(x, y, color) {
                for (let i = 0; i < GAME_CONFIG.PARTICLE_COUNT; i++) {
                    particles.push(new Particle(x, y, color, 5, GAME_CONFIG.PARTICLE_LIFESPAN));
                }
            }

            const inputState = {
                left: false,
                right: false,
                mouseX: null,
            };

            function initEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (gameState.currentPhase === 'LOADING') return;
                    if (e.key === 'ArrowLeft') inputState.left = true;
                    if (e.key === 'ArrowRight') inputState.right = true;
                    if (e.key.toLowerCase() === 'p' && (gameState.currentPhase === 'PLAYING' || gameState.isPaused)) togglePause();
                    if (e.key.toLowerCase() === 'm') toggleMute();
                });
                window.addEventListener('keyup', (e) => {
                    if (gameState.currentPhase === 'LOADING') return;
                    if (e.key === 'ArrowLeft') inputState.left = false;
                    if (e.key === 'ArrowRight') inputState.right = false;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (gameState.currentPhase !== 'PLAYING' || gameState.isPaused) return;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    inputState.mouseX = (e.clientX - rect.left) * scaleX;
                });
                canvas.addEventListener('mouseleave', () => {
                     if (gameState.currentPhase === 'PLAYING' && player) inputState.mouseX = player.x + player.width / 2; 
                });

                canvas.addEventListener('touchstart', (e) => {
                    if (gameState.currentPhase !== 'PLAYING' || gameState.isPaused) return;
                    e.preventDefault();
                    handleTouch(e.touches[0]);
                }, { passive: false });
                canvas.addEventListener('touchmove', (e) => {
                    if (gameState.currentPhase !== 'PLAYING' || gameState.isPaused) return;
                    e.preventDefault();
                    handleTouch(e.touches[0]);
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                     if (gameState.currentPhase === 'PLAYING' && player) inputState.mouseX = player.x + player.width / 2;
                });

                pauseButton.addEventListener('click', togglePause);
                muteButton.addEventListener('click', toggleMute);
                startGameButton.addEventListener('click', () => {
                    mainMenuModal.hide();
                    startGame();
                });
                instructionsButton.addEventListener('click', () => {
                    mainMenuModal.hide();
                    gameState.currentPhase = 'INSTRUCTIONS';
                    instructionsModal.show();
                });
                backToMenuButton.addEventListener('click', () => {
                    instructionsModal.hide();
                    gameState.currentPhase = 'MENU';
                    mainMenuModal.show();
                });
                playAgainButton.addEventListener('click', () => {
                    gameOverModal.hide();
                    startGame();
                });
            }
            
            function handleTouch(touchEvent) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                inputState.mouseX = (touchEvent.clientX - rect.left) * scaleX;
            }

            function resizeGameCanvasMaintainAspectRatio() {
                const nativeAspectRatio = GAME_CONFIG.NATIVE_WIDTH / GAME_CONFIG.NATIVE_HEIGHT;
                let availableWidth = window.innerWidth;
                let availableHeight = window.innerHeight;

                let scaledWidth, scaledHeight;

                if (availableWidth / availableHeight > nativeAspectRatio) {
                    scaledHeight = availableHeight;
                    scaledWidth = scaledHeight * nativeAspectRatio;
                } else {
                    scaledWidth = availableWidth;
                    scaledHeight = scaledWidth / nativeAspectRatio;
                }
                
                const maxContainerWidth = Math.min(1000, window.innerWidth - 20); 
                const maxContainerHeight = Math.min(750, window.innerHeight - document.getElementById('gameTitle').offsetHeight - document.getElementById('statsBar').offsetHeight - 40);
                
                scaledWidth = Math.min(scaledWidth, maxContainerWidth);
                scaledHeight = Math.min(scaledHeight, maxContainerHeight);


                canvasContainer.style.width = Math.floor(scaledWidth) + 'px';
                canvasContainer.style.height = Math.floor(scaledHeight) + 'px';
            }

            function loadAssets() {
                const assetPromises = [];
                const imageSources = {
                    happy: "/generated_images/dalle_0770ee4e-c6a.png",
                    grumpy: "/generated_images/dalle_67090d0c-5a8.png",
                    catcher: "/generated_images/dalle_1de7d1cf-11f.png",
                    powerup: "/generated_images/dalle_9f75f255-8f6.png"
                };

                for (const key in imageSources) {
                    const promise = new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            images[key] = img;
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image: ${key} from ${imageSources[key]}`);
                            images[key] = null; 
                            resolve(); 
                        };
                        img.src = imageSources[key];
                    });
                    assetPromises.push(promise);
                }
                
                const soundFiles = {
                    catchHappy: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(200).join('1'),
                    catchGrumpy: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(200).join('2'),
                    powerUp: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(200).join('3'),
                    gameOver: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(300).join('4'),
                    loseLife: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(200).join('5')
                };

                for (const key in soundFiles) {
                     assetPromises.push(new Promise((resolve) => {
                        sounds[key] = new Howl({ 
                            src: [soundFiles[key]],
                            onload: resolve,
                            onloaderror: (id,err) => {
                                console.error(`Failed to load sound: ${key}`, err);
                                sounds[key] = null; 
                                resolve(); 
                            }
                        });
                    }));
                }
                Howler.volume(0.3);

                return Promise.all(assetPromises);
            }
            
            function playSound(soundName) {
                if (!gameState.isMuted && sounds[soundName] && sounds[soundName].state() === 'loaded') {
                    try {
                        sounds[soundName].play();
                    } catch (e) {
                        console.error("Error playing sound:", soundName, e);
                    }
                }
            }

            function initGame() {
                canvas.width = GAME_CONFIG.NATIVE_WIDTH;
                canvas.height = GAME_CONFIG.NATIVE_HEIGHT;
                resizeGameCanvasMaintainAspectRatio();
                window.addEventListener('resize', resizeGameCanvasMaintainAspectRatio);
                
                mainMenuModal = new bootstrap.Modal(mainMenuModalEl);
                instructionsModal = new bootstrap.Modal(instructionsModalEl);
                gameOverModal = new bootstrap.Modal(gameOverModalEl);

                loadHighScore();
                updateUI();

                player = new Player(
                    GAME_CONFIG.NATIVE_WIDTH / 2 - GAME_CONFIG.PLAYER_WIDTH / 2,
                    GAME_CONFIG.NATIVE_HEIGHT - GAME_CONFIG.PLAYER_HEIGHT - 15, 
                    GAME_CONFIG.PLAYER_WIDTH,
                    GAME_CONFIG.PLAYER_HEIGHT,
                    images.catcher
                );
                fallingItems = [];
                particles = [];
                
                for (let i = 0; i < GAME_CONFIG.STAR_COUNT; i++) {
                    const x = Math.random() * GAME_CONFIG.NATIVE_WIDTH;
                    const y = Math.random() * GAME_CONFIG.NATIVE_HEIGHT;
                    const radius = Math.random() * 1.5 + 0.5; 
                    const speed = Math.random() * (GAME_CONFIG.STAR_MAX_SPEED - GAME_CONFIG.STAR_MIN_SPEED) + GAME_CONFIG.STAR_MIN_SPEED;
                    const brightness = Math.floor(Math.random() * 100 + 100); 
                    const starColor = `rgba(${brightness}, ${brightness}, ${Math.min(255, brightness + 20)}, ${Math.random() * 0.4 + 0.2})`;
                    gameState.backgroundStars.push(new Star(x, y, radius, speed, starColor));
                }
                
                initEventListeners();
                
                loadAssets().then(() => {
                    loadingScreen.style.display = 'none';
                    startGameButton.disabled = false;
                    gameState.currentPhase = 'MENU';
                    mainMenuModal.show();
                     if (gameState.lastTime === 0) { 
                        gameState.lastTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    }
                }).catch(err => {
                    console.error("Critical error loading assets:", err);
                    loadingScreen.innerHTML = "<p class='text-danger'>Error loading assets. Please refresh.</p>";
                });
            }

            function startGame() {
                gameState.score = 0;
                gameState.lives = GAME_CONFIG.INITIAL_LIVES;
                gameState.isPaused = false;
                gameState.currentPhase = 'PLAYING';
                gameState.itemSpawnTimer = 0;
                gameState.nextSpawnInterval = Math.random() * (GAME_CONFIG.ITEM_SPAWN_INTERVAL_MAX - GAME_CONFIG.ITEM_SPAWN_INTERVAL_MIN) + GAME_CONFIG.ITEM_SPAWN_INTERVAL_MIN;
                gameState.currentFallSpeed = GAME_CONFIG.INITIAL_FALL_SPEED;
                gameState.nextSpeedIncreaseScoreThreshold = GAME_CONFIG.SPEED_INCREASE_INTERVAL;
                gameState.comboCount = 0;
                gameState.activePowerUp = null;
                gameState.powerUpTimer = 0;

                fallingItems = [];
                particles = [];
                player.x = GAME_CONFIG.NATIVE_WIDTH / 2 - GAME_CONFIG.PLAYER_WIDTH / 2;
                player.width = GAME_CONFIG.PLAYER_WIDTH; 
                
                updateUI();
                pauseScreen.classList.add('d-none');
                pauseButton.textContent = 'Pause';
                
                gameState.lastTime = performance.now(); 
            }

            function spawnFallingItem() {
                const x = Math.random() * (GAME_CONFIG.NATIVE_WIDTH - GAME_CONFIG.ITEM_SIZE);
                const y = -GAME_CONFIG.ITEM_SIZE;
                let type, image, points;
                const rand = Math.random();

                if (rand < 0.1 && images.powerup) { 
                    type = 'powerup'; image = images.powerup; points = GAME_CONFIG.POINTS_POWERUP;
                } else if (rand < 0.7 && images.happy) { 
                    type = 'happy'; image = images.happy; points = GAME_CONFIG.POINTS_HAPPY;
                } else if (images.grumpy) {
                    type = 'grumpy'; image = images.grumpy; points = 0; 
                } else { 
                    type = 'happy'; image = images.happy ? images.happy : null; points = GAME_CONFIG.POINTS_HAPPY;
                }
                
                if (image) { 
                    fallingItems.push(new FallingItem(x, y, GAME_CONFIG.ITEM_SIZE, image, type, gameState.currentFallSpeed, points));
                }
            }

            function update(dt) {
                if (gameState.currentPhase !== 'PLAYING' || gameState.isPaused) return;

                player.update(dt, inputState);
                gameState.backgroundStars.forEach(star => star.update(dt));


                gameState.itemSpawnTimer += dt * 1000;
                if (gameState.itemSpawnTimer > gameState.nextSpawnInterval) {
                    spawnFallingItem();
                    gameState.itemSpawnTimer = 0;
                    gameState.nextSpawnInterval = Math.random() * (GAME_CONFIG.ITEM_SPAWN_INTERVAL_MAX - GAME_CONFIG.ITEM_SPAWN_INTERVAL_MIN) + GAME_CONFIG.ITEM_SPAWN_INTERVAL_MIN;
                }

                for (let i = fallingItems.length - 1; i >= 0; i--) {
                    const item = fallingItems[i];
                    item.update(dt);

                    if (item.y > GAME_CONFIG.NATIVE_HEIGHT) {
                        if (item.type === 'happy') {
                            loseLife();
                            createParticleEffect(item.x + item.width/2, GAME_CONFIG.NATIVE_HEIGHT - 10, 'rgba(255, 80, 80, 0.7)');
                        }
                        fallingItems.splice(i, 1);
                        continue;
                    }

                    if (checkCollision(player.getHitbox(), item.getHitbox())) {
                        handleItemCatch(item);
                        fallingItems.splice(i, 1);
                    }
                }
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update(dt);
                    if (particles[i].lifespan <= 0) particles.splice(i, 1);
                }
                
                if (gameState.score >= gameState.nextSpeedIncreaseScoreThreshold) {
                     gameState.currentFallSpeed = Math.min(GAME_CONFIG.MAX_FALL_SPEED, gameState.currentFallSpeed + GAME_CONFIG.SPEED_INCREASE_AMOUNT);
                     gameState.nextSpeedIncreaseScoreThreshold += GAME_CONFIG.SPEED_INCREASE_INTERVAL;
                }
                
                if(gameState.activePowerUp) {
                    gameState.powerUpTimer -= dt * 1000;
                    if(gameState.powerUpTimer <= 0) {
                        gameState.activePowerUp = null;
                        player.width = GAME_CONFIG.PLAYER_WIDTH; 
                    }
                }
                updateUI();
            }
            
            function handleItemCatch(item) {
                let comboMultiplier = 1 + gameState.comboCount * GAME_CONFIG.COMBO_BONUS_MULTIPLIER;
                if (gameState.activePowerUp === 'doublePoints') {
                    comboMultiplier *= 2;
                }

                if (item.type === 'happy') {
                    gameState.score += Math.floor(item.points * comboMultiplier);
                    gameState.comboCount++;
                    createParticleEffect(item.x + item.width/2, item.y + item.height/2, 'rgba(255, 215, 0, 0.8)'); 
                    playSound('catchHappy');
                } else if (item.type === 'grumpy') {
                    loseLife();
                    createParticleEffect(item.x + item.width/2, item.y + item.height/2, 'rgba(128, 0, 128, 0.7)'); 
                    playSound('catchGrumpy');
                } else if (item.type === 'powerup') {
                    gameState.score += Math.floor(item.points * comboMultiplier); 
                    activatePowerUp();
                    createParticleEffect(item.x + item.width/2, item.y + item.height/2, 'rgba(0, 255, 255, 0.9)'); 
                    playSound('powerUp');
                }
            }

            function activatePowerUp() {
                const rand = Math.random();
                if (rand < 0.5) { 
                    gameState.activePowerUp = 'wideCatcher';
                    player.width = GAME_CONFIG.PLAYER_WIDTH * 1.5;
                } else { 
                    gameState.activePowerUp = 'doublePoints';
                }
                gameState.powerUpTimer = GAME_CONFIG.POWERUP_DURATION;
            }

            function loseLife() {
                gameState.lives--;
                gameState.comboCount = 0; 
                playSound('loseLife');
                if (gameState.lives <= 0) {
                    gameOver();
                }
            }

            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            function render() {
                ctx.clearRect(0, 0, GAME_CONFIG.NATIVE_WIDTH, GAME_CONFIG.NATIVE_HEIGHT);
                
                ctx.fillStyle = '#03060a'; 
                ctx.fillRect(0,0, GAME_CONFIG.NATIVE_WIDTH, GAME_CONFIG.NATIVE_HEIGHT);

                gameState.backgroundStars.forEach(star => star.draw(ctx));

                fallingItems.forEach(item => item.draw(ctx));
                player.draw(ctx);
                particles.forEach(p => p.draw(ctx));
                
                if (gameState.activePowerUp && gameState.currentPhase === 'PLAYING' && !gameState.isPaused) {
                    ctx.fillStyle = 'rgba(0, 220, 220, 0.9)';
                    ctx.font = 'bold 18px Segoe UI';
                    ctx.textAlign = 'center';
                    let powerUpText = gameState.activePowerUp === 'wideCatcher' ? 'WIDE CATCHER!' : '2X POINTS!';
                    ctx.fillText(`${powerUpText} ${Math.ceil(gameState.powerUpTimer/1000)}s`, GAME_CONFIG.NATIVE_WIDTH / 2, 30);
                }
            }

            function gameLoop(timestamp) {
                const deltaTime = Math.min(0.1, (timestamp - gameState.lastTime) / 1000);
                gameState.lastTime = timestamp;

                if (gameState.currentPhase === 'PLAYING' && !gameState.isPaused) {
                    update(deltaTime);
                }
                
                if (gameState.currentPhase !== 'LOADING') { 
                    render();
                }
                
                if (gameState.currentPhase !== 'GAMEOVER') {
                    requestAnimationFrame(gameLoop);
                } else {
                    gameState.lastTime = 0; 
                }
            }

            function updateUI() {
                scoreDisplay.textContent = gameState.score;
                livesDisplay.textContent = gameState.lives;
                highScoreDisplay.textContent = gameState.highScore;
                const comboValue = (1 + gameState.comboCount * GAME_CONFIG.COMBO_BONUS_MULTIPLIER);
                comboMultiplierDisplay.textContent = `x${comboValue.toFixed(1)}`;
                comboDisplayArea.style.visibility = gameState.comboCount > 0 ? 'visible' : 'hidden';
            }

            function togglePause() {
                if (gameState.currentPhase !== 'PLAYING' && !gameState.isPaused) return; 
                gameState.isPaused = !gameState.isPaused;
                pauseButton.textContent = gameState.isPaused ? 'Resume' : 'Pause';
                pauseScreen.classList.toggle('d-none', !gameState.isPaused);
                if (!gameState.isPaused) {
                    gameState.lastTime = performance.now(); 
                }
            }
            
            function toggleMute() {
                gameState.isMuted = !gameState.isMuted;
                muteButton.textContent = gameState.isMuted ? 'Unmute' : 'Mute';
                Howler.mute(gameState.isMuted);
            }

            function gameOver() {
                gameState.currentPhase = 'GAMEOVER';
                playSound('gameOver');
                if (gameState.score > gameState.highScore) {
                    gameState.highScore = gameState.score;
                    saveHighScore();
                }
                finalScoreDisplay.textContent = gameState.score;
                gameOverHighScoreDisplay.textContent = gameState.highScore;
                gameOverModal.show();
            }

            function loadHighScore() {
                try {
                    const storedHighScore = localStorage.getItem('happyFaceCatchHighScore');
                    if (storedHighScore) {
                        gameState.highScore = parseInt(storedHighScore, 10) || 0;
                    }
                } catch (e) {
                    console.error("Could not load high score from localStorage", e);
                    gameState.highScore = 0;
                }
            }

            function saveHighScore() {
                try {
                    localStorage.setItem('happyFaceCatchHighScore', gameState.highScore.toString());
                } catch (e) {
                    console.error("Could not save high score to localStorage", e);
                }
            }
            
            document.addEventListener('DOMContentLoaded', initGame);
        })();
    </script>

<!-- Injectable Console Log Copier Snippet -->
<div id="appgen2025ConsoleCopyUtil" style="position: fixed; top: 5px; right: 5px; z-index: 9999; padding: 5px; background-color: rgba(0,0,0,0.7); border-radius: 5px; cursor: default;" title="Copy Console Logs for this Tab">
    <button type="button" style="background: none; border: 1px solid #fff; color: #fff; padding: 3px 8px; font-size: 10px; border-radius: 3px; cursor: pointer;">Copy Logs</button>
</div>
<script>
    (function() {
        const utilContainer = document.getElementById('appgen2025ConsoleCopyUtil');
        if (utilContainer) {
            const originalConsoleLog = console.log;
            const originalConsoleError = console.error;
            const originalConsoleWarn = console.warn;
            const originalConsoleInfo = console.info;
            const originalConsoleDebug = console.debug;
            const logs = [];
            function formatLog(type, args) {
                const timestamp = new Date().toISOString();
                const message = Array.from(args).map(arg => {
                    try {
                        if (arg instanceof Error) return arg.stack || arg.toString();
                        if (typeof arg === 'object' && arg !== null) {
                            const getCircularReplacer = () => { const seen = new WeakSet(); return (key, value) => { if (typeof value === "object" && value !== null) { if (seen.has(value)) { return "[Circular]"; } seen.add(value); } return value; }; };
                            return JSON.stringify(arg, getCircularReplacer(), 2);
                        }
                        return String(arg);
                    } catch (e) { return '[Unserializable Object]'; }
                }).join(' ');
                return `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            }
            console.log = function(...args) { const formatted = formatLog('log', args); logs.push(formatted); originalConsoleLog.apply(console, args); };
            console.error = function(...args) { const formatted = formatLog('error', args); logs.push(formatted); originalConsoleError.apply(console, args); };
            console.warn = function(...args) { const formatted = formatLog('warn', args); logs.push(formatted); originalConsoleWarn.apply(console, args); };
            console.info = function(...args) { const formatted = formatLog('info', args); logs.push(formatted); originalConsoleInfo.apply(console, args); };
            console.debug = function(...args) { const formatted = formatLog('debug', args); logs.push(formatted); originalConsoleDebug.apply(console, args); };
            window.onerror = function(message, source, lineno, colno, error) { const errorObj = error || {}; const formatted = formatLog('uncaught_error', [message, `at ${source}:${lineno}:${colno}`, errorObj.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Uncaught Error:', message, 'at', source + ':' + lineno + ':' + colno, error); return false; };
            window.onunhandledrejection = function(event) { const reason = event.reason || {}; const formatted = formatLog('unhandled_rejection', [reason.message || reason, reason.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Unhandled Rejection:', event.reason); };
            const copyButton = utilContainer.querySelector('button');
            if (copyButton) {
                copyButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (logs.length === 0) { alert('No console logs captured yet to copy.'); return; }
                    const logText = logs.join('\n');
                    navigator.clipboard.writeText(logText).then(function() {
                        const originalText = copyButton.textContent; copyButton.textContent = 'Copied!'; copyButton.style.background = '#28a745'; copyButton.style.borderColor = '#28a745';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 2000);
                        originalConsoleInfo.call(console, 'AppGen2025 Util: Console logs copied to clipboard.');
                    }).catch(function(err) {
                        originalConsoleError.call(console, 'AppGen2025 Util: Failed to copy console logs - ', err.name, err.message);
                        alert('Failed to copy logs. See browser console for details. Logs may be too large or permissions denied.');
                        const originalText = copyButton.textContent; copyButton.textContent = 'Failed!'; copyButton.style.background = '#dc3545'; copyButton.style.borderColor = '#dc3545';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 3000);
                    });
                });
            }
        } else { console.error('AppGen2025 Util: Container element "appgen2025ConsoleCopyUtil" not found. Ensure it is correctly injected or present in the HTML.'); }
    })();
</script>
<!-- End of Injectable Snippet -->

</body>
</html>