<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Cartographer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #121212;
            color: #E2E8F0;
            font-family: 'Arial', sans-serif;
        }
        #game-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #1a202c;
            position: relative;
        }
        #game-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            display: block;
            touch-action: none;
            background-color: #000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            pointer-events: auto;
        }
         #gameCanvas.ui-active {
             pointer-events: none;
         }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
        }
        .ui-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        .ui-content {
            pointer-events: auto;
            background-color: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(71, 85, 105, 0.8);
            color: #E2E8F0;
            padding: 20px;
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 11;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .hud-item {
            background-color: rgba(30, 41, 59, 0.8);
            color: #E2E8F0;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .modal-content {
             background-color: #1a202c;
             color: #E2E8F0;
        }
        .modal-header, .modal-footer {
             border-color: #2d3748;
        }
        .btn-close {
             filter: invert(1);
        }
        .atlas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding: 15px;
            justify-items: center;
        }
        .atlas-item {
            background-color: #2d3748;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
             display: flex;
             flex-direction: column;
             justify-content: space-between;
        }
        .atlas-item img {
            width: 100%;
            height: auto;
            border-radius: 4px;
            margin-bottom: 5px;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }
         .atlas-item .image-placeholder {
             width: 100%;
             aspect-ratio: 1 / 1;
             background-color: rgba(0,0,0,0.5);
             border-radius: 4px;
             margin-bottom: 5px;
             display: flex;
             justify-content: center;
             align-items: center;
             color: #9AE6B4;
             font-size: 0.8em;
             text-align: center;
             padding: 5px;
         }
        .atlas-item .constellation-name {
            font-size: 0.9em;
            color: #CBD5E0;
        }
        .loading-indicator {
            color: #9AE6B4;
            font-size: 1.2em;
            margin-top: 20px;
        }
        .error-message {
            color: #FEB2B2;
            font-size: 1em;
            margin-top: 10px;
        }
         #clue-screen .ui-content,
         #shop-screen .ui-content,
         #settings-screen .ui-content {
             text-align: left;
         }
         #mission-list {
             display: flex;
             flex-direction: column;
             align-items: center;
         }
         #mission-list button {
             width: 80%;
             max-width: 300px;
         }
         #shop-items .card {
             width: 100%;
             max-width: 400px;
             margin: 10px auto;
         }
         .charting-controls {
             position: absolute;
             bottom: 20px;
             left: 50%;
             transform: translateX(-50%);
             z-index: 11;
             pointer-events: auto;
             display: flex;
             gap: 10px;
         }
         #instructions-text {
             font-size: 0.9em;
             color: #CBD5E0;
             margin-top: 20px;
             text-align: left;
         }
         #hint-tool-button {
             display: flex;
             align-items: center;
             gap: 5px;
         }
         .hidden {
             display: none !important;
         }
         .hint-line {
             stroke-dasharray: 5, 5;
             stroke: #9AE6B4 !important;
         }
    </style>
</head>
<body data-bs-theme="dark">

    <div id="game-container" class="d-flex flex-column justify-content-center align-items-center min-vh-100 bg-dark">
        <div id="game-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="hud" class="hud hidden">
                <div class="hud-item">Rank: <span id="player-rank">Apprentice</span></div>
                <div class="hud-item">XP: <span id="player-xp">0</span></div>
                <div class="hud-item">Dust: <span id="player-dust">0</span></div>
                 <div class="hud-item hidden" id="hint-uses-hud">Hints: <span id="hint-uses-remaining">0</span></div>
            </div>
        </div>

        <div id="loading-screen" class="ui-overlay active">
            <div class="ui-content text-center">
                <h1>Loading Celestial Cartographer...</h1>
                <div class="spinner-border text-primary mt-3" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>

        <div id="main-menu" class="ui-overlay">
            <div class="ui-content text-center">
                <h1>Celestial Cartographer</h1>
                <p class="lead">Chart the stars, unlock the cosmos.</p>
                <div class="d-grid gap-3 col-md-6 mx-auto mt-4">
                    <button id="btn-start-game" class="btn btn-primary btn-lg">Start New Journey</button>
                    <button id="btn-continue-game" class="btn btn-secondary btn-lg">Continue Journey</button>
                    <button id="btn-atlas" class="btn btn-info btn-lg">View Atlas</button>
                    <button id="btn-shop" class="btn btn-success btn-lg">Observatory</button>
                    <button id="btn-settings" class="btn btn-secondary btn-lg">Settings</button>
                </div>
                 <p id="instructions-text">
                     Welcome, apprentice! Your mission is to chart the constellations. Use the clues and coordinates provided to connect the stars on the canvas. Click two stars to draw a line. Right-click to remove the last line. Submit your chart when ready! Success earns you XP and Cosmic Dust to upgrade your tools and observatory.
                 </p>
            </div>
        </div>

        <div id="mission-select-screen" class="ui-overlay">
            <div class="ui-content">
                <h2>Select Mission</h2>
                <div id="mission-list" class="mt-3">
                </div>
                <button id="btn-back-to-main" class="btn btn-secondary mt-4">Back</button>
            </div>
        </div>

        <div id="clue-screen" class="ui-overlay">
            <div class="ui-content">
                <h2 id="clue-screen-title">Mission Briefing</h2>
                <p id="headmaster-intro" class="text-info"></p>
                <div id="mission-clues" class="mt-3">
                    <h5>Clues:</h5>
                    <p id="clue-text"></p>
                    <h5>Coordinates:</h5>
                    <p id="coordinate-text"></p>
                </div>
                <div id="ai-loading-clues" class="loading-indicator hidden">Generating clues...</div>
                 <div id="ai-error-clues" class="error-message hidden"></div>
                <button id="btn-start-charting" class="btn btn-primary mt-4">Begin Charting</button>
                 <button id="btn-clue-back" class="btn btn-secondary mt-4">Back</button>
            </div>
        </div>

         <div id="charting-ui" class="charting-controls hidden">
             <button id="btn-submit-chart" class="btn btn-success btn-lg" disabled>Submit Chart</button>
             <button id="btn-clear-lines" class="btn btn-warning btn-lg">Clear Lines</button>
              <button id="btn-use-hint" class="btn btn-info btn-lg hidden">
                  <span id="hint-tool-button-text">Use Hint</span>
                  <span id="hint-tool-uses-display">(<span id="hint-uses-button">0</span>)</span>
              </button>
         </div>


        <div class="modal fade" id="missionResultModal" tabindex="-1" aria-labelledby="missionResultModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="missionResultModalLabel">Mission Complete!</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body text-center">
                        <p id="result-message" class="lead"></p>
                        <div id="ai-feedback-display" class="mt-3 text-info"></div>
                        <div id="constellationImageContainer" class="mt-4">
                             <div id="image-loading-indicator" class="loading-indicator hidden">Generating constellation image...</div>
                             <div id="image-error-message" class="error-message hidden"></div>
                             <img id="generated-constellation-image" src="" alt="Constellation Image" class="img-fluid rounded hidden">
                              <div id="image-placeholder" class="image-placeholder hidden">Image Placeholder</div>
                        </div>
                        <p id="reward-text" class="mt-3 text-warning"></p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" id="btn-next-mission" data-bs-dismiss="modal">Next Mission</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="atlas-screen" class="ui-overlay">
            <div class="ui-content">
                <h2>Celestial Atlas</h2>
                <div id="atlas-content" class="atlas-grid mt-3">
                     <p id="atlas-empty-message" class="text-muted text-center w-100">Your atlas is empty. Complete missions to unlock constellations!</p>
                </div>
                <button id="btn-atlas-back" class="btn btn-secondary mt-4">Back</button>
            </div>
        </div>

        <div id="shop-screen" class="ui-overlay">
             <div class="ui-content">
                 <h2>Observatory Upgrades & Tools</h2>
                 <p>Improve your observatory to unlock higher quality constellation images and better tools.</p>
                 <div id="observatory-level" class="mb-3">Current Observatory Level: <span id="current-observatory-level">1</span></div>
                  <h5 class="mt-4">Available for Purchase:</h5>
                 <div id="shop-items" class="mt-3 d-flex flex-column gap-3">
                 </div>
                 <button id="btn-shop-back" class="btn btn-secondary mt-4">Back</button>
             </div>
        </div>

         <div id="settings-screen" class="ui-overlay">
             <div class="ui-content text-center">
                 <h2>Settings</h2>
                 <button id="btn-toggle-sound" class="btn btn-secondary mt-3">Toggle Sound (On)</button>
                 <button id="btn-reset-progress" class="btn btn-danger mt-3">Reset All Progress</button>
                 <button id="btn-settings-back" class="btn btn-secondary mt-4">Back</button>
             </div>
         </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script>
        const GAME_CONFIG = {
            CANVAS_NATIVE_WIDTH: 1024,
            CANVAS_NATIVE_HEIGHT: 768,
            STAR_SIZE: 3,
            STAR_COLOR: '#FFFFFF',
            LINE_COLOR: '#00FFFF',
            LINE_WIDTH: 2,
            PARALLAX_LAYERS: 3,
            PARALLAX_SPEEDS: [0.01, 0.03, 0.06],
             PARALLAX_STAR_SPEED_MULTIPLIER: [0.5, 1.0, 1.5],
            PARALLAX_COLORS: ['#1e3a8a', '#3b82f6', '#60a5fa'],
            STAR_CLICK_RADIUS: 15,
            XP_PER_MISSION: 100,
            DUST_PER_MISSION: 50,
            RANK_LEVELS: [0, 100, 300, 600, 1000, 1500, 2200, 3000, 4000, 5500, 7000],
            RANKS: ["Apprentice", "Cartographer", "Navigator", "Stargazer", "Cosmic Surveyor", "Celestial Master", "Galactic Explorer", "Nebula Nomad", "Void Wanderer", "Astral Sage", "Cosmic Entity"],
            OBSERVATORY_LEVELS: [
                { cost: 0, quality: "simple line-drawing style, minimalist, dark background", hintUses: 1 },
                { cost: 200, quality: "basic artistic rendering, clear style, dark space background", hintUses: 2 },
                { cost: 500, quality: "detailed artistic rendering with subtle effects, vibrant colors, deep space background", hintUses: 3 },
                { cost: 1000, quality: "high-quality photorealistic artistic rendering with dynamic lighting, stunning detail, vast cosmic background", hintUses: 5 }
            ],
            SOUNDS: {
                ambientSpace: 'https://cdn.jsdelivr.net/gh/Tonejs/Tone.js/examples/audio/berlin_2.mp3',
                ambientUI: 'https://assets.mixkit.co/sfx/preview/mixkit-tech-house-bed-929.mp3',
                uiClick: 'https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3',
                starConnect: 'https://assets.mixkit.co/sfx/preview/mixkit-game-bling-award-2061.mp3',
                missionSuccess: 'https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2039.mp3',
                missionFailure: 'https://assets.mixkit.co/sfx/preview/mixkit-game-fail-object-1694.mp3',
                hintUsed: 'https://assets.mixkit.co/sfx/preview/mixkit-quick-win-video-game-notification-269.mp3'
            },
             MISSIONS: [
                 { id: 'ursa_major', name: 'Ursa Major', constellationId: 'Ursa Major', requiredConnections: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 0], [3, 5]] },
                 { id: 'orion', name: 'Orion', constellationId: 'Orion', requiredConnections: [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 5], [2, 6], [3, 7], [4, 8], [5, 9], [6, 10], [7, 11]] },
                 { id: 'cassiopeia', name: 'Cassiopeia', constellationId: 'Cassiopeia', requiredConnections: [[0, 1], [1, 2], [2, 3], [3, 4]] },
                 { id: 'leo', name: 'Leo', constellationId: 'Leo', requiredConnections: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0], [1, 6], [6, 7], [7, 8]] },
                 { id: 'cygnus', name: 'Cygnus', constellationId: 'Cygnus', requiredConnections: [[0, 1], [1, 2], [2, 3], [3, 4], [1, 5], [5, 6]] }
             ],
             STAR_DATA: {
                 'Ursa Major': [
                     { id: 0, x: 0.3, y: 0.2 }, { id: 1, x: 0.4, y: 0.15 }, { id: 2, x: 0.55, y: 0.18 }, { id: 3, x: 0.6, y: 0.3 },
                     { id: 4, x: 0.5, y: 0.35 }, { id: 5, x: 0.4, y: 0.3 }, { id: 6, x: 0.35, y: 0.25 }
                 ],
                 'Orion': [
                     { id: 0, x: 0.4, y: 0.4 }, { id: 1, x: 0.6, y: 0.4 }, { id: 2, x: 0.65, y: 0.6 }, { id: 3, x: 0.35, y: 0.6 },
                     { id: 4, x: 0.45, y: 0.2 }, { id: 5, x: 0.55, y: 0.2 }, { id: 6, x: 0.7, y: 0.8 }, { id: 7, x: 0.3, y: 0.8 },
                     { id: 8, x: 0.45, y: 0.1 }, { id: 9, x: 0.55, y: 0.1 }, { id: 10, x: 0.75, y: 0.9 }, { id: 11, x: 0.25, y: 0.9 }
                 ],
                 'Cassiopeia': [
                      { id: 0, x: 0.2, y: 0.5 }, { id: 1, x: 0.4, y: 0.4 }, { id: 2, x: 0.6, y: 0.5 }, { id: 3, x: 0.8, y: 0.4 }, { id: 4, x: 0.9, y: 0.6 }
                 ],
                 'Leo': [
                     { id: 0, x: 0.3, y: 0.6 }, { id: 1, x: 0.4, y: 0.5 }, { id: 2, x: 0.6, y: 0.4 }, { id: 3, x: 0.75, y: 0.45 },
                     { id: 4, x: 0.8, y: 0.6 }, { id: 5, x: 0.7, y: 0.7 }, { id: 6, x: 0.45, y: 0.3 }, { id: 7, x: 0.55, y: 0.2 }, { id: 8, x: 0.6, y: 0.1 }
                 ],
                 'Cygnus': [
                      { id: 0, x: 0.5, y: 0.1 }, { id: 1, x: 0.5, y: 0.5 }, { id: 2, x: 0.4, y: 0.6 }, { id: 3, x: 0.3, y: 0.7 },
                      { id: 4, x: 0.2, y: 0.8 }, { id: 5, x: 0.6, y: 0.6 }, { id: 6, x: 0.7, y: 0.7 }
                 ]
             },
             TOOLS: [
                 { id: 'hintTool', name: 'Star-Tracking Assistant', cost: 300, description: 'Highlights a correct connection during charting. Uses per mission depend on Observatory Level.' }
             ],
             HINT_LINE_DURATION: 3000
        };

        let canvas
, ctx;
        let gameState = {};
        let lastTime = 0;
        let mousePos = { x: 0, y: 0, isDown: false };

        const uiElements = {};
        let howlerSounds = {};

        const apiManager = {
            async getAIResponse(prompt, settings = {}) {
                uiElements.aiLoadingClues.classList.remove('hidden');
                uiElements.aiErrorClues.classList.add('hidden');
                try {
                    const response = await fetch('/api/ai', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ aiguide: "You are the wise and slightly eccentric Headmaster of the Celestial Academy. Provide guidance, clues, or feedback in a helpful, slightly whimsical, and sometimes poetic tone. Keep responses reasonably concise and focused.", msgforai: prompt, llmSettings: settings })
                    });
                    const data = await response.json();
                    if (response.ok && data.success) {
                        return data.response;
                    } else {
                        console.error('AI API error:', data.error);
                         uiElements.aiErrorClues.textContent = `AI Error: ${data.error || 'Failed to get AI response.'}`;
                         uiElements.aiErrorClues.classList.remove('hidden');
                        return null;
                    }
                } catch (err) {
                    console.error('AI API fetch error:', err);
                    uiElements.aiErrorClues.textContent = 'Network error. Could not get AI response.';
                    uiElements.aiErrorClues.classList.remove('hidden');
                    return null;
                } finally {
                    uiElements.aiLoadingClues.classList.add('hidden');
                }
            },

            async generateConstellationImage(prompt, aspectRatio = "1:1", style = "standard") {
                 uiElements.imageLoadingIndicator.classList.remove('hidden');
                 uiElements.imageErrorMessage.classList.add('hidden');
                 uiElements.generatedConstellationImage.classList.add('hidden');
                 uiElements.imagePlaceholder.classList.add('hidden');
                 uiElements.generatedConstellationImage.src = '';
                try {
                    const response = await fetch('/api/generate-image-on-demand', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: prompt, aspectRatio: aspectRatio, style: style })
                    });
                    const data = await response.json();
                    if (response.ok && data.success) {
                        return data.imageUrl;
                    } else {
                         console.error('Image API error:', data.error);
                         uiElements.imageErrorMessage.textContent = `Image Error: ${data.error || 'Failed to generate image.'}`;
                         uiElements.imageErrorMessage.classList.remove('hidden');
                         uiElements.imagePlaceholder.textContent = 'Image Failed to Load';
                         uiElements.imagePlaceholder.classList.remove('hidden');
                        return null;
                    }
                } catch (err) {
                    console.error('Image API fetch error:', err);
                    uiElements.imageErrorMessage.textContent = 'Network error. Could not generate image.';
                    uiElements.imageErrorMessage.classList.remove('hidden');
                     uiElements.imagePlaceholder.textContent = 'Image Failed to Load';
                    uiElements.imagePlaceholder.classList.remove('hidden');
                    return null;
                } finally {
                    uiElements.imageLoadingIndicator.classList.add('hidden');
                }
            }
        };

        const soundManager = {
            loadSounds() {
                for (const key in GAME_CONFIG.SOUNDS) {
                    howlerSounds[key] = new Howl({
                        src: [GAME_CONFIG.SOUNDS[key]],
                        html5: true,
                        loop: key.startsWith('ambient'),
                        volume: key.startsWith('ambient') ? 0.4 : 0.8,
                        onloaderror: (id, error) => {
                             console.error(`Failed to load sound ${key}:`, error);
                        },
                        onplayerror: (id, error) => {
                             console.error(`Failed to play sound ${key}:`, error);
                        }
                    });
                }
            },
            play(soundId) {
                if (!gameState.sound.isMuted && howlerSounds[soundId] && howlerSounds[soundId].state() === 'loaded') {
                    howlerSounds[soundId].play();
                }
            },
            stop(soundId) {
                 if (howlerSounds[soundId]) {
                     howlerSounds[soundId].stop();
                 }
            },
            setAmbient(soundId, volume = 0.4) {
                this.stopAllAmbient();
                if (!gameState.sound.isMuted && howlerSounds[soundId] && howlerSounds[soundId].state() === 'loaded') {
                    howlerSounds[soundId].volume(volume);
                    howlerSounds[soundId].play();
                }
            },
            stopAllAmbient() {
                for(const key in howlerSounds) {
                    if(key.startsWith('ambient') && howlerSounds[key].playing()) {
                        howlerSounds[key].stop();
                    }
                }
            },
            toggleMute() {
                gameState.sound.isMuted = !gameState.sound.isMuted;
                Howler.mute(gameState.sound.isMuted);
                uiElements.btnToggleSound.textContent = gameState.sound.isMuted ? "Toggle Sound (Off)" : "Toggle Sound (On)";
                if (!gameState.sound.isMuted) {
                    uiManager.showScreen(gameState.currentPhase);
                } else {
                     this.stopAllAmbient();
                }
                saveGame();
            }
        };


        const missionManager = {

             async loadMission(missionId) {
                 const mission = GAME_CONFIG.MISSIONS.find(m => m.id === missionId);
                 if (!mission) {
                     console.error("Mission not found:", missionId);
                     return false;
                 }
                 gameState.missionManager.currentMission = mission;
                 gameState.playerLines = [];
                 gameState.selectedStarId = null;
                 uiElements.btnSubmitChart.disabled = true;

                 const observatoryLevel = gameState.player.observatoryLevel;
                 gameState.player.hintToolUsesRemaining = GAME_CONFIG.OBSERVATORY_LEVELS[observatoryLevel].hintUses;
                 uiManager.updateHUD();


                 const cluePrompt = `Generate a cryptic clue and celestial coordinates for the constellation ${mission.name}, suitable for an apprentice cartographer. Include hints about its shape, mythology, or even poetic verses. Format the response clearly separating the clue text and the coordinates. Use line breaks for clarity. Example: Clue: [Your clue here]\n\nCoordinates:\n[List of coordinates here, e.g., Star A: RA 10h 30m, Dec +20° 15']`;
                 const introPrompt = `Write a short, encouraging, and slightly whimsical message from the Headmaster introducing the mission to chart ${mission.name}.`;

                 uiElements.clueText.textContent = 'Loading...';
                 uiElements.coordinateText.textContent = 'Loading...';
                 uiElements.headmasterIntro.textContent = 'Loading...';
                 uiElements.btnStartCharting.classList.add('hidden');
                 uiElements.aiErrorClues.classList.add('hidden');


                 const headmasterIntro = await apiManager.getAIResponse(introPrompt);
                 if (headmasterIntro) {
                     uiElements.headmasterIntro.textContent = headmasterIntro;
                 } else {
                      uiElements.headmasterIntro.textContent = "Headmaster's message failed to load.";
                 }

                 const cluesResponse = await apiManager.getAIResponse(cluePrompt);
                 if (cluesResponse) {
                     const clueParts = cluesResponse.split('Coordinates:');
                     if (clueParts.length === 2) {
                         uiElements.clueText.textContent = clueParts[0].replace('Clue:', '').trim();
                         uiElements.coordinateText.textContent = clueParts[1].trim();
                         uiElements.btnStartCharting.classList.remove('hidden');
                     } else {
                          uiElements.clueText.textContent = cluesResponse;
                          uiElements.coordinateText.textContent = "Could not parse coordinates from AI response.";
                          uiElements.btnStartCharting.classList.remove('hidden');
                     }
                 } else {
                      uiElements.clueText.textContent = "Mission clues failed to load.";
                      uiElements.coordinateText.textContent = "Coordinates failed to load.";
                 }

                 uiManager.showScreen('CLUE_SCREEN');
                 return true;
             },

             validateChart() {
                 if (!gameState.missionManager.currentMission) return false;

                 const canonicalPlayerLines = gameState.playerLines
                    .filter(line => !line.isHint) // Exclude hint lines from validation
                    .map(line => {
                     const s = Math.min(line.startStarId, line.endStarId);
                     const e = Math.max(line.startStarId, line.endStarId);
                     return `${s}-${e}`;
                 }).sort();

                 const canonicalRequiredLines = gameState.missionManager.currentMission.requiredConnections.map(conn => {
                     const s = Math.min(conn[0], conn[1]);
                     const e = Math.max(conn[0], conn[1]);
                     return `${s}-${e}`;
                 }).sort();

                 if (canonicalPlayerLines.length !== canonicalRequiredLines.length) {
                      return false;
                 }

                 for (const requiredLine of canonicalRequiredLines) {
                     if (!canonicalPlayerLines.includes(requiredLine)) {
                         return false;
                     }
                 }

                 return true;
             },

             getStarsForCurrentMission() {
                 if (!gameState.missionManager.currentMission) return [];
                 return GAME_CONFIG.STAR_DATA[gameState.missionManager.currentMission.constellationId] || [];
             },

             markMissionComplete() {
                 const missionId = gameState.missionManager.currentMission.id;
                 if (!gameState.missionManager.completedMissions.includes(missionId)) {
                      gameState.missionManager.completedMissions.push(missionId);
                      saveGame();
                 }
             },
             getAvailableMissions() {
                 return GAME_CONFIG.MISSIONS.filter(m => !gameState.missionManager.completedMissions.includes(m.id));
             },
             getMissingConnections() {
                  if (!gameState.missionManager.currentMission) return [];
                   const required = gameState.missionManager.currentMission.requiredConnections;
                   const player = gameState.playerLines.filter(line => !line.isHint);

                   const missing = [];
                   for (const reqConn of required) {
                       const reqStart = Math.min(reqConn[0], reqConn[1]);
                       const reqEnd = Math.max(reqConn[0], reqConn[1]);
                       const reqCanonical = `${reqStart}-${reqEnd}`;

                       let found = false;
                       for (const playerLine of player) {
                            const playerStart = Math.min(playerLine.startStarId, playerLine.endStarId);
                            const playerEnd = Math.max(playerLine.startStarId, playerLine.endStarId);
                            const playerCanonical = `${playerStart}-${playerEnd}`;
                            if (reqCanonical === playerCanonical) {
                                found = true;
                                break;
                            }
                       }
                       if (!found) {
                           missing.push(reqConn);
                       }
                   }
                   return missing;
             }
        };

        const starChartRenderer = {
            canvas: null,
            ctx: null,
            backgroundStars: [],
            parallaxOffset: 0,

            init(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = canvasElement.getContext('2d');
                this.generateBackgroundStars();
                this.ctx.imageSmoothingEnabled = false;
            },

            generateBackgroundStars() {
                this.backgroundStars = [];
                const numStars = GAME_CONFIG.CANVAS_NATIVE_WIDTH * GAME_CONFIG.CANVAS_NATIVE_HEIGHT / 800;
                for (let i = 0; i < numStars; i++) {
                    const layer = Math.floor(Math.random() * GAME_CONFIG.PARALLAX_LAYERS);
                    this.backgroundStars.push({
                        x: Math.random() * GAME_CONFIG.CANVAS_NATIVE_WIDTH,
                        y: Math.random() * GAME_CONFIG.CANVAS_NATIVE_HEIGHT,
                        size: Math.random() * 1.2 + 0.3,
                        layer: layer,
                        speedMultiplier: GAME_CONFIG.PARALLAX_STAR_SPEED_MULTIPLIER[layer]
                    });
                }
            },

            draw(currentPhase, mouseX, mouseY, deltaTime) {
                if (!this.ctx) return;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawParallaxBackground(deltaTime);

                if (currentPhase === 'CHARTING') {
                     const stars = missionManager.getStarsForCurrentMission();
                    this.drawStars(stars, gameState.selectedStarId);
                    this.drawLines(gameState.playerLines, stars);
                    this.drawCurrentLine(mouseX, mouseY, stars, gameState.selectedStarId);
                }
            },

            drawParallaxBackground(deltaTime) {
                const baseSpeed = GAME_CONFIG.PARALLAX_SPEEDS[GAME_CONFIG.PARALLAX_LAYERS - 1];
                this.parallaxOffset = (this.parallaxOffset + baseSpeed * deltaTime * 100) % this.canvas.width;


                for (let i = 0; i < GAME_CONFIG.PARALLAX_LAYERS; i++) {
                    const speed = GAME_CONFIG.PARALLAX_SPEEDS[i];
                    const offsetX = -this.parallaxOffset * (speed / baseSpeed);

                    this.ctx.save();
                    this.ctx.translate(offsetX, 0);

                    this.ctx.globalAlpha = 0.2 + i * 0.05;
                    this.ctx.fillStyle = '#FFFFFF';

                     this.backgroundStars.forEach(star => {
                          if (star.layer === i) {
                               const starOffsetX = star.x + this.parallaxOffset * star.speedMultiplier;
                               const wrappedX = (starOffsetX % this.canvas.width + this.canvas.width) % this.canvas.width;
                               const wrappedY = star.y;

                               this.ctx.beginPath();
                               this.ctx.arc(wrappedX, wrappedY, star.size, 0, Math.PI * 2);
                               this.ctx.fill();

                               if (wrappedX < star.size) {
                                    this.ctx.beginPath();
                                    this.ctx.arc(wrappedX + this.canvas.width, wrappedY, star.size, 0, Math.PI * 2);
                                    this.ctx.fill();
                               } else if (wrappedX > this.canvas.width - star.size) {
                                     this.ctx.beginPath();
                                     this.ctx.arc(wrappedX - this.canvas.width, wrappedY, star.size, 0, Math.PI * 2);
                                     this.ctx.fill();
                               }
                          }
                     });

                    this.ctx.restore();
                }
            },

            drawStars(stars, selectedStarId) {
                stars.forEach(star => {
                    const x = star.x * this.canvas.width;
                    const y = star.y * this.canvas.height;

                    this.ctx.fillStyle = star.id === selectedStarId ? GAME_CONFIG.LINE_COLOR : GAME_CONFIG.STAR_COLOR;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, GAME_CONFIG.STAR_SIZE, 0, Math.PI * 2);
                    this.ctx.fill();

                    if (star.id === selectedStarId) {
                        this.ctx.strokeStyle = GAME_CONFIG.LINE_COLOR;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, GAME_CONFIG.STAR_CLICK_RADIUS, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });
            },

            drawLines(lines, stars) {
                this.ctx.lineWidth = GAME_CONFIG.LINE_WIDTH;
                this.ctx.lineCap = 'round';

                lines.forEach(line => {
                    const startStar = stars.find(s => s.id === line.startStarId);
                    const endStar = stars.find(s => s.id === line.endStarId);

                    if (startStar && endStar) {
                         this.ctx.strokeStyle = line.isHint ? '#9AE6B4' : GAME_CONFIG.LINE_COLOR;
                         if (line.isHint) {
                             this.ctx.setLineDash([5, 5]);
                         } else {
                             this.ctx.setLineDash([]);
                         }

                        this.ctx.beginPath();
                        this.ctx.moveTo(startStar.x * this.canvas.width, startStar.y * this.canvas.height);
                        this.ctx.lineTo(endStar.x * this.canvas.width, endStar.y * this.canvas.height);
                        this.ctx.stroke();
                    }
                });
                 this.ctx.setLineDash([]); // Reset line dash
            },

            drawCurrentLine(mouseX, mouseY, stars, selectedStarId) {
                if (selectedStarId !== null) {
                    const startStar = stars.find(s => s.id === selectedStarId);
                    if (startStar) {
                        this.ctx.strokeStyle = GAME_CONFIG.LINE_COLOR;
                        this.ctx.lineWidth = GAME_CONFIG.LINE_WIDTH;
                        this.ctx.lineCap = 'round';
                        this.ctx.beginPath();
                        this.ctx.moveTo(startStar.x * this.canvas.width, startStar.y * this.canvas.height);
                        const canvasMouse = this.screenToCanvas(mouseX, mouseY);
                        this.ctx.lineTo(canvasMouse.x, canvasMouse.y);
                        this.ctx.stroke();
                    }
                }
            },

            screenToCanvas(screenX, screenY) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (screenX - rect.left) * scaleX,
                    y: (screenY - rect.top) * scaleY
                };
            },

             getStarAt(screenX, screenY, stars) {
                 const canvasCoords = this.screenToCanvas(screenX, screenY);
                 for (const star of stars) {
                     const starX = star.x * this.canvas.width;
                     const starY = star.y * this.canvas.height;
                     const distance = Math.sqrt((canvasCoords.x - starX) ** 2 + (canvasCoords.y - starY) ** 2);
                     if (distance < GAME_CONFIG.STAR_CLICK_RADIUS) {
                         return star;
                     }
                 }
                 return null;
             }
        };

        const uiManager = {
            init(elements) {
                Object.assign(uiElements, elements);
            },

            showScreen(phase) {
                gameState.currentPhase = phase;
                this.hideAllScreens();

                const uiScreenElements = [
                    uiElements.loadingScreen, uiElements.mainMenu, uiElements.missionSelectScreen,
                    uiElements.clueScreen, uiElements.atlasScreen, uiElements.shopScreen, uiElements.settingsScreen
                ];

                if (phase === 'CHARTING') {
                    uiElements.gameCanvas.classList.remove('ui-active');
                    uiElements.hud.classList.remove('hidden');
                    uiElements.chartingUi.classList.remove('hidden');
                    soundManager.setAmbient('ambientSpace');
                     if (gameState.player.unlockedTools.includes('hintTool')) {
                          uiElements.btnUseHint.classList.remove('hidden');
                          uiElements.hintUsesHud.classList.remove('hidden');
                     } else {
                          uiElements.btnUseHint.classList.add('hidden');
                          uiElements.hintUsesHud.classList.add('hidden');
                     }
                } else {
                    uiElements.gameCanvas.classList.add('ui-active');
                    uiElements.hud.classList.add('hidden');
                    uiElements.chartingUi.classList.add('hidden');
                     uiElements.btnUseHint.classList.add('hidden');
                     uiElements.hintUsesHud.classList.add('hidden');
                     soundManager.setAmbient('ambientUI');
                }

                let targetScreen = null;
                switch (phase) {
                    case 'LOADING': targetScreen = uiElements.loadingScreen; break;
                    case 'MAIN_MENU':
                        targetScreen = uiElements.mainMenu;
                         if (localStorage.getItem('celestialCartographerSave')) {
                             uiElements.btnContinueGame.classList.remove('hidden');
                         } else {
                             uiElements.btnContinueGame.classList.add('hidden');
                         }
                        break;
                    case 'MISSION_SELECT':
                        targetScreen = uiElements.missionSelectScreen;
                        this.populateMissionList();
                        break;
                    case 'CLUE_SCREEN':
                        targetScreen = uiElements.clueScreen;
                        uiElements.clueScreenTitle.textContent = `Mission: ${gameState.missionManager.currentMission.name}`;
                        break;
                    case 'CHARTING':
                         break;
                    case 'MISSION_RESULT':
                        uiElements.hud.classList.remove('hidden');
                        break;
                    case 'ATLAS':
                        targetScreen = uiElements.atlasScreen;
                        this.populateAtlas();
                        break;
                    case 'SHOP':
                         targetScreen = uiElements.shopScreen;
                         this.populateShop();
                        break;
                     case 'SETTINGS':
                         targetScreen = uiElements.settingsScreen;
                         break;
                }

                if (targetScreen) {
                    targetScreen.classList.add('active');
                }
            },

            hideAllScreens() {
                const screens = [
                    uiElements.loadingScreen, uiElements.mainMenu, uiElements.missionSelectScreen,
                    uiElements.clueScreen, uiElements.atlasScreen, uiElements.shopScreen,
                    uiElements.settingsScreen
                ];
                screens.forEach(screen => screen.classList.remove('active'));
            },

            updateHUD() {
                uiElements.playerRank.textContent = gameState.player.rank;
                uiElements.playerXP.textContent = gameState.player.xp;
                uiElements.playerDust.textContent = gameState.player.dust;
                 uiElements.hintUsesRemaining.textContent = gameState.player.hintToolUsesRemaining;
                 uiElements.hintUsesButton.textContent = gameState.player.hintToolUsesRemaining;
                 if (gameState.player.unlockedTools.includes('hintTool')) {
                      uiElements.btnUseHint.disabled = gameState.player.hintToolUsesRemaining <= 0;
                 } else {
                      uiElements.btnUseHint.disabled = true;
                 }
            },

            populateMissionList() {
                 const missionListDiv = uiElements.missionList;
                 missionListDiv.innerHTML = '';

                 const available = missionManager.getAvailableMissions();

                 if (available.length === 0) {
                     missionListDiv.innerHTML = '<p class="text-warning">You have completed all available missions! Congratulations, Master Cartographer!</p>';
                     return;
                 }

                 available.forEach(mission => {
                     const button = document.createElement('button');
                     button.classList.add('btn', 'btn-outline-primary', 'm-2');
                     button.textContent = mission.name;
                     button.addEventListener('click', async () => {
                         soundManager.play('uiClick');
                         await missionManager.loadMission(mission.id);
                     });
                     missionListDiv.appendChild(button);
                 });
            },

             async showMissionResult(success) {
                 const modal = new bootstrap.Modal(uiElements.missionResultModal);
                 uiElements.aiFeedbackDisplay.textContent = '';
                 uiElements.generatedConstellationImage.classList.add('hidden');
                 uiElements.imagePlaceholder.classList.add('hidden');
                 uiElements.imageLoadingIndicator.classList.add('hidden');
                 uiElements.imageErrorMessage.classList.add('hidden');
                 uiElements.generatedConstellationImage.src = '';

                 if (success) {
                     uiElements.missionResultModalLabel.textContent = "Mission Success!";
                     uiElements.resultMessage.textContent = `You successfully charted ${gameState.missionManager.currentMission.name}!`;
                     const feedback = await apiManager.getAIResponse(`The player successfully charted the constellation ${gameState.missionManager.currentMission.name}. Provide encouraging and insightful feedback from the Headmaster, perhaps mentioning their growing skill or the beauty of the constellation.`);
                     if (feedback) uiElements.aiFeedbackDisplay.textContent = feedback;

                     const xpEarned = GAME_CONFIG.XP_PER_MISSION;
                     const dustEarned = GAME_CONFIG.DUST_PER_MISSION;
                     gameState.player.addXP(xpEarned);
                     gameState.player.addDust(dustEarned);
                     uiElements.rewardText.textContent = `Rewards: +${xpEarned} XP, +${dustEarned} Cosmic Dust`;

                     missionManager.markMissionComplete();
                     soundManager.play('missionSuccess');

                     const observatoryQuality = GAME_CONFIG.OBSERVATORY_LEVELS[gameState.player.observatoryLevel].quality;
                     const imagePrompt = `Generate a beautiful, artistic image of the constellation ${gameState.missionManager.currentMission.name} in a dark space background, incorporating stars connected by subtle lines that form the constellation shape. The style should be ${observatoryQuality}. Focus on the visual representation of the constellation itself, making it feel grand and celestial.`;
                     const imageUrl = await apiManager.generateConstellationImage(imagePrompt, "1:1", "hd");
                     if (imageUrl) {
                          uiElements.generatedConstellationImage.src = imageUrl;
                          uiElements.generatedConstellationImage.classList.remove('hidden');
                          gameState.player.addToAtlas(gameState.missionManager.currentMission.constellationId, imageUrl);
                     } else {
                          uiElements.imagePlaceholder.textContent = "Failed to generate image.";
                          uiElements.imagePlaceholder.classList.remove('hidden');
                     }


                 } else {
                     uiElements.missionResultModalLabel.textContent = "Mission Failed";
                     uiElements.resultMessage.textContent = `Your chart for ${gameState.missionManager.currentMission.name} was incorrect.`;
                     const feedback = await apiManager.getAIResponse(`The player failed to correctly chart the constellation ${gameState.missionManager.currentMission.name}. Provide constructive but gentle feedback from the Headmaster, perhaps suggesting they review the clues or coordinates.`);
                     if (feedback) uiElements.aiFeedbackDisplay.textContent = feedback;
                     uiElements.rewardText.textContent = "No rewards this time.";
                     soundManager.play('missionFailure');

                      uiElements.imagePlaceholder.textContent = "Chart Incorrect - Image Obscured";
                      uiElements.imagePlaceholder.classList.remove('hidden');
                 }

                 modal.show();
             },

             populateAtlas() {
                 const atlasContentDiv = uiElements.atlasContent;
                 atlasContentDiv.innerHTML = '';

                 const constellations = Object.keys(gameState.player.atlas);

                 if (constellations.length === 0) {
                     uiElements.atlasEmptyMessage.classList.remove('hidden');
                     return;
                 } else {
                      uiElements.atlasEmptyMessage.classList.add('hidden');
                 }

                 constellations.forEach(constellationId => {
                     const imageUrl = gameState.player.atlas[constellationId];
                     const constellationName = GAME_CONFIG.MISSIONS.find(m => m.constellationId === constellationId)?.name || constellationId;

                     const itemDiv = document.createElement('div');
                     itemDiv.classList.add('atlas-item');

                     const img = document.createElement('img');
                     img.alt = `${constellationName} Constellation`;
                     img.onload = () => {
                          itemDiv.appendChild(img);
                     };
                     img.onerror = () => {
                          console.error("Failed to load atlas image:", imageUrl);
                           const placeholder = document.createElement('div');
                           placeholder.classList.add('image-placeholder');
                           placeholder.textContent = 'Image Failed to Load';
                           itemDiv.appendChild(placeholder);
                     };
                     img.src = imageUrl;


                     const nameSpan = document.createElement('div');
                     nameSpan.classList.add('constellation-name');
                     nameSpan.textContent = constellationName;

                     itemDiv.appendChild(nameSpan);
                     atlasContentDiv.appendChild(itemDiv);
                 });
             },

             populateShop() {
                 const shopItemsDiv = uiElements.shopItems;
                 shopItemsDiv.innerHTML = '';

                 uiElements.currentObservatoryLevel.textContent = gameState.player.observatoryLevel + 1;

                 const currentLevel = gameState.player.observatoryLevel;
                 const nextLevel = currentLevel + 1;

                 // Display current observatory level info
                 const currentLevelInfo = GAME_CONFIG.OBSERVATORY_LEVELS[currentLevel];
                 const currentItem = document.createElement('div');
                 currentItem.classList.add('alert', 'alert-info', 'm-2');
                 currentItem.textContent = `Current Observatory Level ${currentLevel + 1} (${currentLevelInfo.quality}) - Hint Uses: ${currentLevelInfo.hintUses}`;
                 shopItemsDiv.appendChild(currentItem);


                 // Observatory Upgrade (Show only the next level if available)
                 if (nextLevel < GAME_CONFIG.OBSERVATORY_LEVELS.length) {
                     const upgradeLevelInfo = GAME_CONFIG.OBSERVATORY_LEVELS[nextLevel];
                     const upgradeCost = upgradeLevelInfo.cost;
                     const upgradeItem = document.createElement('div');
                     upgradeItem.classList.add('card', 'bg-secondary', 'text-light', 'm-2');
                     upgradeItem.innerHTML = `
                         <div class="card-body">
                             <h5 class="card-title">Upgrade Observatory to Level ${nextLevel + 1}</h5>
                             <p class="card-text">Unlocks: ${upgradeLevelInfo.quality}</p>
                              <p class="card-text">Hint Uses per Mission: ${upgradeLevelInfo.hintUses}</p>
                             <p class="card-text">Cost: <span class="text-warning">${upgradeCost} Dust</span></p>
                             <button class="btn btn-primary btn-buy-upgrade" data-cost="${upgradeCost}" ${gameState.player.dust < upgradeCost ? 'disabled' : ''}>Buy Upgrade</button>
                         </div>
                     `;
                     shopItemsDiv.appendChild(upgradeItem);
                 } else {
                     const maxLevelItem = document.createElement('div');
                     maxLevelItem.classList.add('alert', 'alert-success', 'm-2');
                     maxLevelItem.textContent = `Observatory is at max level (${currentLevel + 1})!`;
                     shopItemsDiv.appendChild(maxLevelItem);
                 }


                 // Tools
                  GAME_CONFIG.TOOLS.forEach(tool => {
                     const isOwned = gameState.player.unlockedTools.includes(tool.id);
                     const toolItem = document.createElement('div');
                      toolItem.classList.add('card', 'bg-secondary', 'text-light', 'm-2');
                      toolItem.innerHTML = `
                          <div class="card-body">
                              <h5 class="card-title">${tool.name}</h5>
                              <p class="card-text">${tool.description}</p>
                              ${isOwned
                                  ? '<p class="card-text text-success">Owned</p>'
                                  : `<p class="card-text">Cost: <span class="text-warning">${tool.cost} Dust</span></p><button class="btn btn-primary btn-buy-tool" data-tool-id="${tool.id}" data-cost="${tool.cost}" ${gameState.player.dust < tool.cost ? 'disabled' : ''}>Buy Tool</button>`
                              }
                          </div>
                      `;
                     shopItemsDiv.appendChild(toolItem);
                 });


                 shopItemsDiv.querySelectorAll('.btn-buy-upgrade').forEach(button => {
                     button.addEventListener('click', (event) => {
                         const cost = parseInt(event.target.dataset.cost);
                         buyUpgrade(cost);
                     });
                 });

                  shopItemsDiv.querySelectorAll('.btn-buy-tool').forEach(button => {
                     button.addEventListener('click', (event) => {
                         const toolId = event.target.dataset.toolId;
                         const cost = parseInt(event.target.dataset.cost);
                         buyTool(toolId, cost);
                     });
                 });
             }

        };

        const inputHandler = {
            init(canvasElement) {
                canvasElement.addEventListener('mousemove', this.handleMouseMove);
                canvasElement.addEventListener('mousedown', this.handleMouseDown);
                canvasElement.addEventListener('mouseup', this.handleMouseUp);
                canvasElement.addEventListener('click', this.handleClick);
                 canvasElement.addEventListener('contextmenu', this.handleRightClick);
            },

            handleMouseMove(event) {
                mousePos.x = event.clientX;
                mousePos.y = event.clientY;
            },

            handleMouseDown(event) {
                if (event.button === 0) {
                    mousePos.isDown = true;
                }
            },

            handleMouseUp(event) {
                if (event.button === 0) {
                    mousePos.isDown = false;
                }
            },

            handleClick(event) {
                 if (gameState.currentPhase === 'CHARTING') {
                     const stars = missionManager.getStarsForCurrentMission();
                     const clickedStar = starChartRenderer.getStarAt(event.clientX, event.clientY, stars);

                     if (clickedStar) {
                         soundManager.play('uiClick');

                         if (gameState.selectedStarId === null) {
                             gameState.selectedStarId = clickedStar.id;
                         } else if (gameState.selectedStarId === clickedStar.id) {
                             gameState.selectedStarId = null;
                         } else {
                             const newLine = {
                                 startStarId: gameState.selectedStarId,
                                 endStarId: clickedStar.id,
                                 isHint: false
                             };

                             const lineExists = gameState.playerLines.some(line =>
                                 !line.isHint && // Only check non-hint lines
                                 ((line.startStarId === newLine.startStarId && line.endStarId === newLine.endStarId) ||
                                 (line.startStarId === newLine.endStarId
 && line.endStarId === newLine.startStarId))
                             );

                             if (!lineExists) {
                                 gameState.playerLines.push(newLine);
                                 soundManager.play('starConnect');
                                 const requiredConnectionsCount = gameState.missionManager.currentMission.requiredConnections.length;
                                  const playerLinesCount = gameState.playerLines.filter(line => !line.isHint).length;
                                 if (playerLinesCount >= requiredConnectionsCount) {
                                      uiElements.btnSubmitChart.disabled = false;
                                 }
                             }

                             gameState.selectedStarId = null;
                         }
                     } else {
                         gameState.selectedStarId = null;
                     }
                 }
            },
             handleRightClick(event) {
                 event.preventDefault();
                 if (gameState.currentPhase === 'CHARTING') {
                      // Remove the last non-hint line added by the player
                      const playerLines = gameState.playerLines.filter(line => !line.isHint);
                      if (playerLines.length > 0) {
                           const lastPlayerLine = playerLines[playerLines.length - 1];
                           gameState.playerLines = gameState.playerLines.filter(line => line !== lastPlayerLine);
                           soundManager.play('uiClick');
                            const requiredConnectionsCount = gameState.missionManager.currentMission.requiredConnections.length;
                            const currentPlayerLinesCount = gameState.playerLines.filter(line => !line.isHint).length;
                            if (currentPlayerLinesCount < requiredConnectionsCount) {
                                 uiElements.btnSubmitChart.disabled = true;
                            }
                      }
                 }
             }
        };

        function createInitialGameState() {
            return {
                currentPhase: 'LOADING',
                player: {
                    rank: "Apprentice",
                    xp: 0,
                    dust: 0,
                    observatoryLevel: 0,
                    atlas: {},
                    unlockedTools: [],
                    hintToolUsesRemaining: 0,
                     addXP(amount) {
                         this.xp += amount;
                         this.checkRankUp();
                         uiManager.updateHUD();
                         saveGame();
                     },
                     addDust(amount) {
                         this.dust += amount;
                         uiManager.updateHUD();
                         saveGame();
                     },
                     checkRankUp() {
                         let newRankIndex = 0;
                         for (let i = 0; i < GAME_CONFIG.RANK_LEVELS.length; i++) {
                             if (this.xp >= GAME_CONFIG.RANK_LEVELS[i]) {
                                 newRankIndex = i;
                             } else {
                                 break;
                             }
                         }
                         this.rank = GAME_CONFIG.RANKS[newRankIndex];
                     },
                     addToAtlas(constellationId, imageUrl) {
                         this.atlas[constellationId] = imageUrl;
                         saveGame();
                     }
                },
                missionManager: {
                    currentMission: null,
                    completedMissions: [],
                },
                sound: {
                     isMuted: false
                },
                selectedStarId: null,
                playerLines: []
            };
        }

        function saveGame() {
            try {
                const saveState = {
                    player: {
                        rank: gameState.player.rank,
                        xp: gameState.player.xp,
                        dust: gameState.player.dust,
                        observatoryLevel: gameState.player.observatoryLevel,
                        atlas: gameState.player.atlas,
                        unlockedTools: gameState.player.unlockedTools,
                         hintToolUsesRemaining: gameState.player.hintToolUsesRemaining // Save current hint uses
                    },
                    missionManager: {
                        completedMissions: gameState.missionManager.completedMissions,
                    },
                     sound: {
                         isMuted: gameState.sound.isMuted
                     }
                };
                localStorage.setItem('celestialCartographerSave', JSON.stringify(saveState));
            } catch (e) {
                console.error("Failed to save game:", e);
            }
        }

        function loadGame() {
            try {
                const savedState = localStorage.getItem('celestialCartographerSave');
                if (savedState) {
                    const loadedState = JSON.parse(savedState);
                    gameState = createInitialGameState();

                    if (loadedState.player) {
                        Object.assign(gameState.player, loadedState.player);
                        // Ensure properties exist for backward compatibility
                         if (typeof gameState.player.observatoryLevel === 'undefined') gameState.player.observatoryLevel = 0;
                         if (!Array.isArray(gameState.player.unlockedTools)) gameState.player.unlockedTools = [];
                         if (typeof gameState.player.hintToolUsesRemaining === 'undefined') gameState.player.hintToolUsesRemaining = 0;
                         if (typeof gameState.player.atlas === 'undefined') gameState.player.atlas = {};
                    }
                     if (loadedState.missionManager) {
                         Object.assign(gameState.missionManager, loadedState.missionManager);
                          if (!Array.isArray(gameState.missionManager.completedMissions)) gameState.missionManager.completedMissions = [];
                     }
                     if (loadedState.sound) {
                         Object.assign(gameState.sound, loadedState.sound);
                          if (typeof gameState.sound.isMuted === 'undefined') gameState.sound.isMuted = false;
                     }


                    Howler.mute(gameState.sound.isMuted);
                     uiElements.btnToggleSound.textContent = gameState.sound.isMuted ? "Toggle Sound (Off)" : "Toggle Sound (On)";

                    gameState.player.checkRankUp(); // Recalculate rank on load

                    console.log("Game loaded successfully.");
                    return true;
                } else {
                    console.log("No save data found.");
                    gameState = createInitialGameState();
                    return false;
                }
            } catch (e) {
                console.error("Failed to load game:", e);
                gameState = createInitialGameState();
                return false;
            }
        }

        function buyUpgrade(cost) {
             const nextLevel = gameState.player.observatoryLevel + 1;
             if (gameState.player.dust >= cost && nextLevel < GAME_CONFIG.OBSERVATORY_LEVELS.length) {
                 gameState.player.dust -= cost;
                 gameState.player.observatoryLevel = nextLevel;
                 uiManager.updateHUD();
                 uiManager.populateShop();
                 saveGame();
                 soundManager.play('uiClick');
                 return true;
             } else {
                  soundManager.play('missionFailure');
                 return false;
             }
        }

        function buyTool(toolId, cost) {
            if (gameState.player.dust >= cost && !gameState.player.unlockedTools.includes(toolId)) {
                gameState.player.dust -= cost;
                gameState.player.unlockedTools.push(toolId);
                 uiManager.updateHUD();
                uiManager.populateShop();
                saveGame();
                soundManager.play('uiClick');
                return true;
            } else {
                 soundManager.play('missionFailure');
                return false;
            }
        }

        function useHintTool() {
             if (!gameState.player.unlockedTools.includes('hintTool')) {
                  return;
             }
             if (gameState.player.hintToolUsesRemaining <= 0) {
                 return;
             }

             const missingConnections = missionManager.getMissingConnections();

             if (missingConnections.length === 0) {
                 return;
             }

             soundManager.play('hintUsed');
             gameState.player.hintToolUsesRemaining--;
             uiManager.updateHUD();
             saveGame();

             const hintConnection = missingConnections[Math.floor(Math.random() * missingConnections.length)];

             gameState.playerLines.push({
                 startStarId: hintConnection[0],
                 endStarId: hintConnection[1],
                 isHint: true
             });

             setTimeout(() => {
                 gameState.playerLines = gameState.playerLines.filter(line => !line.isHint);
             }, GAME_CONFIG.HINT_LINE_DURATION);
        }


        function resizeGameCanvasMaintainAspectRatio() {
            const gameWrapper = document.getElementById('game-wrapper');
            const nativeAspectRatio = GAME_CONFIG.CANVAS_NATIVE_WIDTH / GAME_CONFIG.CANVAS_NATIVE_HEIGHT;
            let windowWidth = window.innerWidth;
            let windowHeight = window.innerHeight;
            const windowAspectRatio = windowWidth / windowHeight;

            let scaledWidth, scaledHeight;

            if (windowAspectRatio > nativeAspectRatio) {
                scaledHeight = windowHeight;
                scaledWidth = scaledHeight * nativeAspectRatio;
            } else {
                scaledWidth = windowWidth;
                scaledHeight = scaledWidth / nativeAspectRatio;
            }

            canvas.style.width = Math.floor(scaledWidth) + 'px';
            canvas.style.height = Math.floor(scaledHeight) + 'px';

            if (gameWrapper) {
                 gameWrapper.style.width = canvas.style.width;
                 gameWrapper.style.height = canvas.style.height;
            }
        }


        function update(deltaTime) {
        }

        function render(deltaTime) {
            starChartRenderer.draw(
                gameState.currentPhase,
                mousePos.x,
                mousePos.y,
                deltaTime
            );
        }

        function gameLoop(timestamp) {
            const deltaTime = Math.min(0.1, (timestamp - lastTime) / 1000);
            lastTime = timestamp;

            update(deltaTime);
            render(deltaTime);

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('gameCanvas');
            canvas.width = GAME_CONFIG.CANVAS_NATIVE_WIDTH;
            canvas.height = GAME_CONFIG.CANVAS_NATIVE_HEIGHT;
            starChartRenderer.init(canvas);

            uiManager.init({
                gameContainer: document.getElementById('game-container'),
                gameWrapper: document.getElementById('game-wrapper'),
                gameCanvas: document.getElementById('gameCanvas'),
                loadingScreen: document.getElementById('loading-screen'),
                mainMenu: document.getElementById('main-menu'),
                missionSelectScreen: document.getElementById('mission-select-screen'),
                clueScreen: document.getElementById('clue-screen'),
                hud: document.getElementById('hud'),
                missionResultModal: document.getElementById('missionResultModal'),
                atlasScreen: document.getElementById('atlas-screen'),
                shopScreen: document.getElementById('shop-screen'),
                settingsScreen: document.getElementById('settings-screen'),
                playerRank: document.getElementById('player-rank'),
                playerXP: document.getElementById('player-xp'),
                playerDust: document.getElementById('player-dust'),
                 hintUsesHud: document.getElementById('hint-uses-hud'),
                 hintUsesRemaining: document.getElementById('hint-uses-remaining'),
                btnStartGame: document.getElementById('btn-start-game'),
                 btnContinueGame: document.getElementById('btn-continue-game'),
                btnAtlas: document.getElementById('btn-atlas'),
                btnShop: document.getElementById('btn-shop'),
                btnSettings: document.getElementById('btn-settings'),
                missionList: document.getElementById('mission-list'),
                btnBackToMain: document.getElementById('btn-back-to-main'),
                clueScreenTitle: document.getElementById('clue-screen-title'),
                headmasterIntro: document.getElementById('headmaster-intro'),
                missionClues: document.getElementById('mission-clues'),
                clueText: document.getElementById('clue-text'),
                coordinateText: document.getElementById('coordinate-text'),
                 aiLoadingClues: document.getElementById('ai-loading-clues'),
                 aiErrorClues: document.getElementById('ai-error-clues'),
                btnStartCharting: document.getElementById('btn-start-charting'),
                 btnClueBack: document.getElementById('btn-clue-back'),
                 chartingUi: document.getElementById('charting-ui'),
                 btnSubmitChart: document.getElementById('btn-submit-chart'),
                 btnClearLines: document.getElementById('btn-clear-lines'),
                 btnUseHint: document.getElementById('btn-use-hint'),
                 hintToolButtonText: document.getElementById('hint-tool-button-text'),
                 hintUsesButton: document.getElementById('hint-uses-button'),
                 resultMessage: document.getElementById('result-message'),
                 aiFeedbackDisplay: document.getElementById('ai-feedback-display'),
                 constellationImageContainer: document.getElementById('constellationImageContainer'),
                 imageLoadingIndicator: document.getElementById('image-loading-indicator'),
                 imageErrorMessage: document.getElementById('image-error-message'),
                 generatedConstellationImage: document.getElementById('generated-constellation-image'),
                 imagePlaceholder: document.getElementById('image-placeholder'),
                 rewardText: document.getElementById('reward-text'),
                 btnNextMission: document.getElementById('btn-next-mission'),
                 atlasContent: document.getElementById('atlas-content'),
                 atlasEmptyMessage: document.getElementById('atlas-empty-message'),
                 btnAtlasBack: document.getElementById('btn-atlas-back'),
                 currentObservatoryLevel: document.getElementById('current-observatory-level'),
                 shopItems: document.getElementById('shop-items'),
                 btnShopBack: document.getElementById('btn-shop-back'),
                 btnToggleSound: document.getElementById('btn-toggle-sound'),
                 btnResetProgress: document.getElementById('btn-reset-progress'),
                 btnSettingsBack: document.getElementById('btn-settings-back')

            });

            const hasSave = loadGame();
            uiManager.updateHUD();

            window.addEventListener('resize', resizeGameCanvasMaintainAspectRatio);
            inputHandler.init(canvas);

            uiElements.btnStartGame.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 localStorage.removeItem('celestialCartographerSave');
                 gameState = createInitialGameState();
                 uiManager.updateHUD();
                 uiManager.showScreen('MISSION_SELECT');
            });

            uiElements.btnContinueGame.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MISSION_SELECT');
            });

            uiElements.btnAtlas.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('ATLAS');
            });

            uiElements.btnShop.addEventListener('click', () => {

                 soundManager.play('uiClick');
                 uiManager.showScreen('SHOP');
            });

             uiElements.btnSettings.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('SETTINGS');
            });

            uiElements.btnBackToMain.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MAIN_MENU');
            });

             uiElements.btnClueBack.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MISSION_SELECT');
            });

            uiElements.btnStartCharting.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('CHARTING');
                 gameState.playerLines = [];
                 gameState.selectedStarId = null;
                 uiElements.btnSubmitChart.disabled = true;
                 uiManager.updateHUD();
            });

             uiElements.btnSubmitChart.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 const success = missionManager.validateChart();
                 uiManager.showMissionResult(success);
             });

             uiElements.btnClearLines.addEventListener('click', () => {
                  soundManager.play('uiClick');
                  gameState.playerLines = gameState.playerLines.filter(line => !line.isHint); // Only clear player lines, keep hints for now? Or clear all? Let's clear player lines only.
                  gameState.selectedStarId = null;
                  uiElements.btnSubmitChart.disabled = true;
             });

             uiElements.btnUseHint.addEventListener('click', () => {
                  useHintTool();
             });


             uiElements.btnNextMission.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MISSION_SELECT');
             });

             uiElements.btnAtlasBack.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MAIN_MENU');
             });

             uiElements.btnShopBack.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MAIN_MENU');
             });

             uiElements.btnSettingsBack.addEventListener('click', () => {
                 soundManager.play('uiClick');
                 uiManager.showScreen('MAIN_MENU');
             });

             uiElements.btnToggleSound.addEventListener('click', () => {
                 soundManager.toggleMute();
             });

             uiElements.btnResetProgress.addEventListener('click', () => {
                  if (confirm("Are you sure you want to reset all your progress? This cannot be undone.")) {
                      gameState = createInitialGameState();
                      localStorage.removeItem('celestialCartographerSave');
                      loadGame();
                      uiManager.updateHUD();
                      uiManager.showScreen('MAIN_MENU');
                      soundManager.play('uiClick');
                  }
             });


            soundManager.loadSounds();
            resizeGameCanvasMaintainAspectRatio();
            uiManager.showScreen(hasSave ? 'MAIN_MENU' : 'MAIN_MENU');
            requestAnimationFrame(gameLoop);
        });
    </script>




<!-- Injectable Console Log Copier Snippet -->
<div id="appgen2025ConsoleCopyUtil" style="position: fixed; top: 5px; right: 5px; z-index: 9999; padding: 5px; background-color: rgba(0,0,0,0.7); border-radius: 5px; cursor: default;" title="Copy Console Logs for this Tab">
    <button type="button" style="background: none; border: 1px solid #fff; color: #fff; padding: 3px 8px; font-size: 10px; border-radius: 3px; cursor: pointer;">Copy Logs</button>
</div>
<script>
    (function() {
        const utilContainer = document.getElementById('appgen2025ConsoleCopyUtil');
        if (utilContainer) {
            const originalConsoleLog = console.log;
            const originalConsoleError = console.error;
            const originalConsoleWarn = console.warn;
            const originalConsoleInfo = console.info;
            const originalConsoleDebug = console.debug;
            const logs = [];
            function formatLog(type, args) {
                const timestamp = new Date().toISOString();
                const message = Array.from(args).map(arg => {
                    try {
                        if (arg instanceof Error) return arg.stack || arg.toString();
                        if (typeof arg === 'object' && arg !== null) {
                            const getCircularReplacer = () => { const seen = new WeakSet(); return (key, value) => { if (typeof value === "object" && value !== null) { if (seen.has(value)) { return "[Circular]"; } seen.add(value); } return value; }; };
                            return JSON.stringify(arg, getCircularReplacer(), 2);
                        }
                        return String(arg);
                    } catch (e) { return '[Unserializable Object]'; }
                }).join(' ');
                return `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            }
            console.log = function(...args) { const formatted = formatLog('log', args); logs.push(formatted); originalConsoleLog.apply(console, args); };
            console.error = function(...args) { const formatted = formatLog('error', args); logs.push(formatted); originalConsoleError.apply(console, args); };
            console.warn = function(...args) { const formatted = formatLog('warn', args); logs.push(formatted); originalConsoleWarn.apply(console, args); };
            console.info = function(...args) { const formatted = formatLog('info', args); logs.push(formatted); originalConsoleInfo.apply(console, args); };
            console.debug = function(...args) { const formatted = formatLog('debug', args); logs.push(formatted); originalConsoleDebug.apply(console, args); };
            window.onerror = function(message, source, lineno, colno, error) { const errorObj = error || {}; const formatted = formatLog('uncaught_error', [message, `at ${source}:${lineno}:${colno}`, errorObj.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Uncaught Error:', message, 'at', source + ':' + lineno + ':' + colno, error); return false; };
            window.onunhandledrejection = function(event) { const reason = event.reason || {}; const formatted = formatLog('unhandled_rejection', [reason.message || reason, reason.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Unhandled Rejection:', event.reason); };
            const copyButton = utilContainer.querySelector('button');
            if (copyButton) {
                copyButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (logs.length === 0) { alert('No console logs captured yet to copy.'); return; }
                    const logText = logs.join('\n');
                    navigator.clipboard.writeText(logText).then(function() {
                        const originalText = copyButton.textContent; copyButton.textContent = 'Copied!'; copyButton.style.background = '#28a745'; copyButton.style.borderColor = '#28a745';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 2000);
                        originalConsoleInfo.call(console, 'AppGen2025 Util: Console logs copied to clipboard.');
                    }).catch(function(err) {
                        originalConsoleError.call(console, 'AppGen2025 Util: Failed to copy console logs - ', err.name, err.message);
                        alert('Failed to copy logs. See browser console for details. Logs may be too large or permissions denied.');
                        const originalText = copyButton.textContent; copyButton.textContent = 'Failed!'; copyButton.style.background = '#dc3545'; copyButton.style.borderColor = '#dc3545';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 3000);
                    });
                });
            }
        } else { console.error('AppGen2025 Util: Container element "appgen2025ConsoleCopyUtil" not found. Ensure it is correctly injected or present in the HTML.'); }
    })();
</script>
<!-- End of Injectable Snippet -->

</body>
</html>