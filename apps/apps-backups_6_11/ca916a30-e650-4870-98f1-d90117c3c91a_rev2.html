<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesmerizing Particle Playground</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #121212;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #app-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background-color: transparent;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background-color: rgba(33, 33, 33, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            color: #e0e0e0;
        }
        #hud p {
            margin: 0;
            line-height: 1.4;
        }

        .modal {
            background-color: #212121 !important;
            color: #e0e0e0;
        }
        .modal-footer {
            background-color: #1a1a1a !important;
            border-top: 1px solid #333 !important;
        }
        .modal .modal-content h4 {
            color: #e0e0e0;
            margin-bottom: 20px;
        }
        .modal .modal-content label.active {
            color: #e0e0e0 !important;
        }

        .input-field label {
            color: #e0e0e0 !important;
        }

        .input-field input[type=text]:focus + label {
            color: #9c27b0 !important;
        }

        .input-field input[type=text]:focus {
            border-bottom: 1px solid #9c27b0 !important;
            box-shadow: 0 1px 0 0 #9c27b0 !important;
        }

        .select-wrapper input.select-dropdown {
            background-color: #424242 !important;
            color: #e0e0e0 !important;
            border-bottom: 1px solid #616161 !important;
            border-radius: 4px 4px 0 0;
            padding-left: 12px;
            height: 3rem;
            line-height: 3rem;
        }
        .select-wrapper .caret {
            fill: #e0e0e0 !important;
        }
        .dropdown-content li > span {
            color: #e0e0e0 !important;
        }
        .dropdown-content li > a {
            color: #e0e0e0 !important;
        }
        .dropdown-content li.selected {
            background-color: #424242 !important;
        }
        .dropdown-content {
            background-color: #424242 !important;
        }

        input[type=range]::-webkit-slider-thumb {
            background-color: #9c27b0;
            border: none;
            box-shadow: 0 0 0 4px rgba(156, 39, 176, 0.4);
        }
        input[type=range]::-moz-range-thumb {
            background-color: #9c27b0;
            border: none;
            box-shadow: 0 0 0 4px rgba(156, 39, 176, 0.4);
        }
        input[type=range]::-ms-thumb {
            background-color: #9c27b0;
            border: none;
            box-shadow: 0 0 0 4px rgba(156, 39, 176, 0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
            background-color: #616161;
            border-radius: 5px;
        }
        input[type=range]::-moz-range-track {
            background-color: #616161;
            border-radius: 5px;
        }
        input[type=range]::-ms-track {
            background-color: #616161;
            border-radius: 5px;
        }

        .switch label input[type=checkbox]:checked+.lever {
            background-color: #616161 !important;
        }
        .switch label input[type=checkbox]:checked+.lever:after {
            background-color: #9c27b0 !important;
        }
        .switch label .lever {
            background-color: #424242 !important;
        }
        .switch label .lever:after {
            background-color: #bdbdbd !important;
        }
    </style>
</head>
<body class="grey darken-4">
    <div id="app-container">
        <canvas id="particleCanvas"></canvas>

        <div id="hud" class="card-panel grey darken-3 white-text z-depth-2">
            <p>Particles: <span id="currentParticleCount">0</span></p>
            <p>FPS: <span id="fpsDisplay">0</span></p>
            <p>Mode: <span id="currentInteractionMode">Attract</span></p>
        </div>

        <div class="fixed-action-btn horizontal click-to-toggle" style="bottom: 45px; right: 24px;">
            <a class="btn-floating btn-large waves-effect waves-light purple darken-3">
                <i class="material-icons">menu</i>
            </a>
            <ul>
                <li><a class="btn-floating purple darken-1 modal-trigger tooltipped" data-position="left" data-tooltip="Settings" href="#settingsModal" id="settingsBtn"><i class="material-icons">settings</i></a></li>
                <li><a class="btn-floating red darken-1 waves-effect waves-light tooltipped" data-position="left" data-tooltip="Reset Simulation" id="onScreenResetBtn"><i class="material-icons">refresh</i></a></li>
                <li><a class="btn-floating orange darken-1 waves-effect waves-light tooltipped" data-position="left" data-tooltip="Clear Canvas" id="onScreenClearBtn"><i class="material-icons">clear_all</i></a></li>
            </ul>
        </div>

        <div id="settingsModal" class="modal grey darken-3">
            <div class="modal-content white-text">
                <h4>Simulation Settings</h4>
                <div class="row">
                    <div class="col s12 input-field">
                        <label class="white-text active">Interaction Mode:</label>
                        <select id="interactionModeSelect">
                            <option value="attract">Attract</option>
                            <option value="repel">Repel</option>
                            <option value="create">Create</option>
                            <option value="erase">Erase</option>
                        </select>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="particleCountSlider" class="white-text">Max Particles: <span id="particleCountValue"></span></label>
                            <input type="range" id="particleCountSlider" min="100" max="5000" value="1000">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="particleSizeSlider" class="white-text">Base Particle Size: <span id="particleSizeValue"></span></label>
                            <input type="range" id="particleSizeSlider" min="1" max="10" value="3">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="particleSizeVarianceSlider" class="white-text">Particle Size Variance: <span id="particleSizeVarianceValue"></span></label>
                            <input type="range" id="particleSizeVarianceSlider" min="0" max="1" step="0.01" value="0.5">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="forceStrengthSlider" class="white-text">Force Strength: <span id="forceStrengthValue"></span></label>
                            <input type="range" id="forceStrengthSlider" min="0.1" max="10" step="0.1" value="1">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="particleLifetimeSlider" class="white-text">Particle Lifetime (s): <span id="particleLifetimeValue"></span></label>
                            <input type="range" id="particleLifetimeSlider" min="1" max="120" step="0.1" value="5">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="frictionSlider" class="white-text">Friction: <span id="frictionValue"></span></label>
                            <input type="range" id="frictionSlider" min="0.9" max="0.999" step="0.001" value="0.98">
                        </p>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="particleColorHueSlider" class="white-text">Particle Color Hue: <span id="particleColorHueValue"></span></label>
                            <input type="range" id="particleColorHueSlider" min="0" max="360" value="200">
                        </p>
                    </div>
                    <div class="col s12">
                        <div class="switch">
                            <label class="white-text">
                                Fixed Hue
                                <input type="checkbox" id="randomColorSpectrumToggle">
                                <span class="lever"></span>
                                Random Spectrum
                            </label>
                        </div>
                    </div>
                    <div class="col s12">
                        <div class="switch">
                            <label class="white-text">
                                Trails Off
                                <input type="checkbox" id="trailsToggle" checked>
                                <span class="lever"></span>
                                Trails On
                            </label>
                        </div>
                    </div>
                    <div class="col s12 input-field">
                        <label class="white-text active">Blending Mode:</label>
                        <select id="blendingModeSelect">
                            <option value="source-over">Normal</option>
                            <option value="lighter">Lighter (Glow)</option>
                            <option value="screen">Screen</option>
                            <option value="overlay">Overlay</option>
                        </select>
                    </div>
                    <div class="col s12">
                        <div class="switch">
                            <label class="white-text">
                                No Continuous Spawn
                                <input type="checkbox" id="continuousSpawnToggle">
                                <span class="lever"></span>
                                Continuous Spawn
                            </label>
                        </div>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="continuousSpawnRateSlider" class="white-text">Continuous Spawn Rate: <span id="continuousSpawnRateValue"></span></label>
                            <input type="range" id="continuousSpawnRateSlider" min="0.1" max="10" step="0.1" value="1">
                        </p>
                    </div>
                    <div class="col s12">
                        <div class="switch">
                            <label class="white-text">
                                Auto Reset Off
                                <input type="checkbox" id="autoResetToggle">
                                <span class="lever"></span>
                                Auto Reset On
                            </label>
                        </div>
                    </div>
                    <div class="input-field col s12">
                        <p class="range-field">
                            <label for="autoResetIntervalSlider" class="white-text">Auto Reset Interval (s): <span id="autoResetIntervalValue"></span></label>
                            <input type="range" id="autoResetIntervalSlider" min="5" max="120" step="1" value="30">
                        </p>
                    </div>
                    <div class="col s12 input-field">
                        <label class="white-text active">Pre-set Scene:</label>
                        <select id="sceneSelect">
                            <option value="default">Default (Random)</option>
                            <option value="galaxy">Galaxy Swirl</option>
                            <option value="plasma">Electric Plasma</option>
                            <option value="rain">Rainfall</option>
                            <option value="fireflies">Fireflies</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer grey darken-4">
                <a href="#!" class="modal-close waves-effect waves-green btn-flat white-text">Close</a>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script>
        const settings = {
            interactionMode: 'attract',
            maxParticles: 1000,
            particleSize: 3,
            particleSizeVariance: 0.5,
            forceStrength: 1,
            particleLifetime: 5,
            friction: 0.98,
            trails: true,
            blendingMode: 'lighter',
            particleColorHue: 200,
            randomColorSpectrumEnabled: false,
            continuousSpawnEnabled: false,
            continuousSpawnRate: 1,
            autoResetEnabled: false,
            autoResetInterval: 30,
            interactionRadius: 50
        };

        class Particle {
            constructor() {
                this.isAlive = false;
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.ax = 0;
                this.ay = 0;
                this.size = 0;
                this.colorHue = 0;
                this.initialLifetime = 0;
                this.lifetimeRemaining = 0;
                this.alpha = 1;
            }

            init(x, y, vx, vy, baseSize, baseColorHue, lifetime) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.ax = 0;
                this.ay = 0;
                this.initialLifetime = lifetime;
                this.lifetimeRemaining = lifetime;
                this.alpha = 1;
                this.isAlive = true;

                this.size = baseSize;
                if (settings.particleSizeVariance > 0) {
                    this.size = baseSize * (1 + (Math.random() - 0.5) * settings.particleSizeVariance * 2);
                    this.size = Math.max(0.5, this.size);
                }

                this.colorHue = baseColorHue;
                if (settings.randomColorSpectrumEnabled) {
                    this.colorHue = Math.random() * 360;
                } else {
                    this.colorHue = (baseColorHue + Math.random() * 60 - 30 + 360) % 360;
                }
            }

            update(dt) {
                if (!this.isAlive) return;

                this.vx += this.ax * dt;
                this.vy += this.ay * dt;

                this.vx *= settings.friction;
                this.vy *= settings.friction;

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                this.ax = 0;
                this.ay = 0;

                this.lifetimeRemaining -= dt;
                this.alpha = Math.max(0, this.lifetimeRemaining / this.initialLifetime);

                if (this.lifetimeRemaining <= 0) {
                    this.isAlive = false;
                }
            }

            applyForce(forceX, forceY) {
                this.ax += forceX;
                this.ay += forceY;
            }

            draw(ctx) {
                if (!this.isAlive) return;
                ctx.fillStyle = `hsla(${this.colorHue}, 100%, 70%, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class InteractionPoint {
            constructor(id, x, y, type) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = settings.interactionRadius;
            }

            updatePosition(x, y) {
                this.x = x;
                this.y = y;
            }

            draw(ctx) {
                ctx.strokeStyle = `rgba(156, 39, 176, 0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        class SimulationManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                this.particlePool = [];
                this.interactionPoints = new Map();
                this.lastTime = 0;
                this.rafId = null;
                this.spawnAccumulator = 0;
                this.timeSinceLastReset = 0;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdateTime = 0;
            }

            init() {
                this.resizeCanvas();
                window.addEventListener('resize', this.resizeCanvas.bind(this));
                this.canvas.addEventListener('mousedown', this.handlePointerDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handlePointerMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handlePointerUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handlePointerUp.bind(this));

                this.canvas.addEventListener('touchstart', this.handlePointerDown.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handlePointerMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handlePointerUp.bind(this));
                this.canvas.addEventListener('touchcancel', this.handlePointerUp.bind(this));

                this.populateInitialParticles();
                this.startLoop(0);
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            startLoop(currentTime) {
                try {
                    if (!this.lastTime) this.lastTime = currentTime;
                    const dt = (currentTime - this.lastTime) / 1000;
                    this.lastTime = currentTime;

                    this.update(dt);
                    this.draw();

                    this.frameCount++;
                    if (currentTime - this.lastFpsUpdateTime >= 1000) {
                        this.fps = this.frameCount;
                        this.frameCount = 0;
                        this.lastFpsUpdateTime = currentTime;
                        UIManager.updateHUD(this.particles.length, this.fps, settings.interactionMode);
                    }
                } catch (error) {
                    console.error('Simulation loop error:', error);
                }
                this.rafId = requestAnimationFrame(this.startLoop.bind(this));
            }

            update(dt) {
                const aliveParticles = [];

                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    if (!particle.isAlive) {
                        this.particlePool.push(particle);
                        continue;
                    }

                    this.interactionPoints.forEach(point => {
                        const dx = point.x - particle.x;
                        const dy = point.y - particle.y;
                        const distanceSq = dx * dx + dy * dy;
                        const distance = Math.sqrt(distanceSq);

                        if (distance < 1) {
                            particle.applyForce(Math.random() - 0.5, Math.random() - 0.5);
                            return;
                        }

                        const forceMagnitude = settings.forceStrength * (1 / (distanceSq + 100)) * 50000;

                        const forceX = forceMagnitude * (dx / distance);
                        const forceY = forceMagnitude * (dy / distance);

                        if (settings.interactionMode === 'attract') {
                            particle.applyForce(forceX, forceY);
                        } else if (settings.interactionMode === 'repel') {
                            particle.applyForce(-forceX, -forceY);
                        } else if (settings.interactionMode === 'erase' && distance < point.radius) {
                            particle.isAlive = false;
                        }
                    });

                    particle.update(dt);
                    if (particle.isAlive) {
                        aliveParticles.push(particle);
                    } else {
                        this.particlePool.push(particle);
                    }
                }
                this.particles = aliveParticles;

                if (settings.interactionMode === 'create' && this.interactionPoints.size > 0) {
                    this.interactionPoints.forEach(point => {
                        const particlesToSpawn = Math.min(5, settings.maxParticles - this.particles.length);
                        for (let i = 0; i < particlesToSpawn; i++) {
                            const spawnX = point.x + (Math.random() - 0.5) * 20;
                            const spawnY = point.y + (Math.random() - 0.5) * 20;
                            const initialVx = (Math.random() - 0.5) * 50;
                            const initialVy = (Math.random() - 0.5) * 50;
                            this.addParticle(spawnX, spawnY, initialVx, initialVy);
                        }
                    });
                }

                if (settings.continuousSpawnEnabled && this.particles.length < settings.maxParticles) {
                    this.spawnAccumulator += settings.continuousSpawnRate * dt;
                    while (this.spawnAccumulator >= 1 && this.particles.length < settings.maxParticles) {
                        const x = Math.random() * this.canvas.width;
                        const y = Math.random() * this.canvas.height;
                        const vx = (Math.random() - 0.5) * 50;
                        const vy = (Math.random() - 0.5) * 50;
                        this.addParticle(x, y, vx, vy);
                        this.spawnAccumulator--;
                    }
                }

                while (this.particles.length > settings.maxParticles) {
                    const particleToRemove = this.particles.shift();
                    particleToRemove.isAlive = false;
                    this.particlePool.push(particleToRemove);
                }

                if (settings.autoResetEnabled) {
                    this.timeSinceLastReset += dt;
                    if (this.timeSinceLastReset >= settings.autoResetInterval) {
                        this.resetSimulation();
                        this.timeSinceLastReset = 0;
                    }
                }
            }

            draw() {
                if (settings.trails) {
                    this.ctx.fillStyle = 'rgba(18, 18, 18, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }

                this.ctx.globalCompositeOperation = settings.blendingMode;

                for (let i = 0; i < this.particles.length; i++) {
                    this.particles[i].draw(this.ctx);
                }

                this.interactionPoints.forEach(point => {
                    point.draw(this.ctx);
                });
            }

            addParticle(x, y, vx, vy) {
                let particle;
                if (this.particlePool.length > 0) {
                    particle = this.particlePool.pop();
                } else {
                    particle = new Particle();
                }
                particle.init(x, y, vx, vy, settings.particleSize, settings.particleColorHue, settings.particleLifetime);
                this.particles.push(particle);
            }

            populateInitialParticles() {
                this.particles = [];
                this.particlePool = [];
                for (let i = 0; i < settings.maxParticles; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const vx = (Math.random() - 0.5) * 50;
                    const vy = (Math.random() - 0.5) * 50;
                    this.addParticle(x, y, vx, vy);
                }
                this.timeSinceLastReset = 0;
            }

            handlePointerDown(event) {
                event.preventDefault();
                if (event.touches) {
                    Array.from(event.changedTouches).forEach(touch => {
                        this.interactionPoints.set(touch.identifier, new InteractionPoint(touch.identifier, touch.clientX, touch.clientY, 'touch'));
                    });
                } else {
                    this.interactionPoints.set('mouse', new InteractionPoint('mouse', event.clientX, event.clientY, 'mouse'));
                }
            }

            handlePointerMove(event) {
                event.preventDefault();
                if (event.touches) {
                    Array.from(event.changedTouches).forEach(touch => {
                        const point = this.interactionPoints.get(touch.identifier);
                        if (point) {
                            point.updatePosition(touch.clientX, touch.clientY);
                        }
                    });
                } else {
                    const point = this.interactionPoints.get('mouse');
                    if (point) {
                        point.updatePosition(event.clientX, event.clientY);
                    }
                }
            }

            handlePointerUp(event) {
                event.preventDefault();
                if (event.touches) {
                    Array.from(event.changedTouches).forEach(touch => {
                        this.interactionPoints.delete(touch.identifier);
                    });
                } else {
                    this.interactionPoints.delete('mouse');
                }
            }

            applySettings() {
                this.particles.forEach(p => {
                    if (p.isAlive) {
                        p.init(p.x, p.y, p.vx, p.vy, settings.particleSize, settings.particleColorHue, settings.particleLifetime);
                    }
                });
                if (this.ctx) {
                    this.ctx.globalCompositeOperation = settings.blendingMode;
                }
                UIManager.updateHUD(this.particles.length, this.fps, settings.interactionMode);
            }

            resetSimulation() {
                this.particles = [];
                this.particlePool = [];
                this.interactionPoints.clear();
                this.populateInitialParticles();
                this.applySettings();
                this.timeSinceLastReset = 0;
            }

            clearCanvas() {
                this.particles = [];
                this.particlePool = [];
                this.interactionPoints.clear();
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                UIManager.updateHUD(0, this.fps, settings.interactionMode);
            }

            loadScene(sceneName) {
                switch (sceneName) {
                    case 'default':
                        settings.maxParticles = 1000;
                        settings.particleSize = 3;
                        settings.particleSizeVariance = 0.5;
                        settings.forceStrength = 1;
                        settings.particleLifetime = 5;
                        settings.friction = 0.98;
                        settings.trails = true;
                        settings.blendingMode = 'lighter';
                        settings.particleColorHue = 200;
                        settings.randomColorSpectrumEnabled = false;
                        settings.continuousSpawnEnabled = false;
                        settings.continuousSpawnRate = 1;
                        settings.autoResetEnabled = false;
                        settings.autoResetInterval = 30;
                        break;
                    case 'galaxy':
                        settings.maxParticles = 3000;
                        settings.particleSize = 2;
                        settings.particleSizeVariance = 0.8;
                        settings.forceStrength = 0.5;
                        settings.particleLifetime = 8;
                        settings.friction = 0.995;
                        settings.trails = true;
                        settings.blendingMode = 'lighter';
                        settings.particleColorHue = 280;
                        settings.randomColorSpectrumEnabled = false;
                        settings.continuousSpawnEnabled = false;
                        settings.continuousSpawnRate = 1;
                        settings.autoResetEnabled = false;
                        settings.autoResetInterval = 30;
                        break;
                    case 'plasma':
                        settings.maxParticles = 2000;
                        settings.particleSize = 4;
                        settings.particleSizeVariance = 0.3;
                        settings.forceStrength = 1.5;
                        settings.particleLifetime = 3;
                        settings.friction = 0.95;
                        settings.trails = true;
                        settings.blendingMode = 'screen';
                        settings.particleColorHue = 0;
                        settings.randomColorSpectrumEnabled = true;
                        settings.continuousSpawnEnabled = true;
                        settings.continuousSpawnRate = 5;
                        settings.autoResetEnabled = false;
                        settings.autoResetInterval = 30;
                        break;
                    case 'rain':
                        settings.maxParticles = 500;
                        settings.particleSize = 1;
                        settings.particleSizeVariance = 0.1;
                        settings.forceStrength = 0.1;
                        settings.particleLifetime = 2;
                        settings.friction = 0.999;
                        settings.trails = false;
                        settings.blendingMode = 'source-over';
                        settings.particleColorHue = 220;
                        settings.randomColorSpectrumEnabled = false;
                        settings.continuousSpawnEnabled = true;
                        settings.continuousSpawnRate = 0.5;
                        settings.autoResetEnabled = false;
                        settings.autoResetInterval = 30;
                        break;
                    case 'fireflies':
                        settings.maxParticles = 300;
                        settings.particleSize = 6;
                        settings.particleSizeVariance = 0.7;
                        settings.forceStrength = 0.8;
                        settings.particleLifetime = 10;
                        settings.friction = 0.99;
                        settings.trails = true;
                        settings.blendingMode = 'lighter';
                        settings.particleColorHue = 60;
                        settings.randomColorSpectrumEnabled = false;
                        settings.continuousSpawnEnabled = true;
                        settings.continuousSpawnRate = 0.2;
                        settings.autoResetEnabled = false;
                        settings.autoResetInterval = 30;
                        break;
                }
                UIManager.updateUIFromSettings();
                this.resetSimulation();
            }
        }

        const UIManager = {
            dom: {},

            init() {
                this.cacheDomElements();
                M.Modal.init(document.querySelectorAll('.modal'));
                M.FormSelect.init(document.querySelectorAll('select'));
                M.Tooltip.init(document.querySelectorAll('.tooltipped'));
                M.FloatingActionButton.init(document.querySelectorAll('.fixed-action-btn'), {
                    direction: 'left',
                    hoverEnabled: false
                });
            },

            cacheDomElements() {
                this.dom.interactionModeSelect = document.getElementById('interactionModeSelect');
                this.dom.particleCountSlider = document.getElementById('particleCountSlider');
                this.dom.particleCountValue = document.getElementById('particleCountValue');
                this.dom.particleSizeSlider = document.getElementById('particleSizeSlider');
                this.dom.particleSizeValue = document.getElementById('particleSizeValue');
                this.dom.particleSizeVarianceSlider = document.getElementById('particleSizeVarianceSlider');
                this.dom.particleSizeVarianceValue = document.getElementById('particleSizeVarianceValue');
                this.dom.forceStrengthSlider = document.getElementById('forceStrengthSlider');
                this.dom.forceStrengthValue = document.getElementById('forceStrengthValue');
                this.dom.particleLifetimeSlider = document.getElementById('particleLifetimeSlider');
                this.dom.particleLifetimeValue = document.getElementById('particleLifetimeValue');
                this.dom.frictionSlider = document.getElementById('frictionSlider');
                this.dom.frictionValue = document.getElementById('frictionValue');
                this.dom.particleColorHueSlider = document.getElementById('particleColorHueSlider');
                this.dom.particleColorHueValue = document.getElementById('particleColorHueValue');
                this.dom.randomColorSpectrumToggle = document.getElementById('randomColorSpectrumToggle');
                this.dom.trailsToggle = document.getElementById('trailsToggle');
                this.dom.blendingModeSelect = document.getElementById('blendingModeSelect');
                this.dom.continuousSpawnToggle = document.getElementById('continuousSpawnToggle');
                this.dom.continuousSpawnRateSlider = document.getElementById('continuousSpawnRateSlider');
                this.dom.continuousSpawnRateValue = document.getElementById('continuousSpawnRateValue');
                this.dom.autoResetToggle = document.getElementById('autoResetToggle');
                this.dom.autoResetIntervalSlider = document.getElementById('autoResetIntervalSlider');
                this.dom.autoResetIntervalValue = document.getElementById('autoResetIntervalValue');
                this.dom.sceneSelect = document.getElementById('sceneSelect');
                
                this.dom.onScreenResetBtn = document.getElementById('onScreenResetBtn');
                this.dom.onScreenClearBtn = document.getElementById('onScreenClearBtn');

                this.dom.currentParticleCountSpan = document.getElementById('currentParticleCount');
                this.dom.fpsDisplaySpan = document.getElementById('fpsDisplay');
                this.dom.currentInteractionModeSpan = document.getElementById('currentInteractionMode');
            },

            bindEventListeners(simulationManager) {
                this.dom.interactionModeSelect.addEventListener('change', (e) => {
                    settings.interactionMode = e.target.value;
                    this.updateHUD(simulationManager.particles.length, simulationManager.fps, settings.interactionMode);
                });

                this.dom.particleCountSlider.addEventListener('input', (e) => {
                    const newMaxParticles = parseInt(e.target.value);
                    if (newMaxParticles !== settings.maxParticles) {
                        settings.maxParticles = newMaxParticles;
                        this.updateSliderDisplay('particleCountSlider', 'particleCountValue', settings.maxParticles);
                        simulationManager.resetSimulation();
                    }
                });

                this.dom.particleSizeSlider.addEventListener('input', (e) => {
                    settings.particleSize = parseFloat(e.target.value);
                    this.updateSliderDisplay('particleSizeSlider', 'particleSizeValue', settings.particleSize);
                    simulationManager.applySettings();
                });

                this.dom.particleSizeVarianceSlider.addEventListener('input', (e) => {
                    settings.particleSizeVariance = parseFloat(e.target.value);
                    this.updateSliderDisplay('particleSizeVarianceSlider', 'particleSizeVarianceValue', settings.particleSizeVariance);
                    simulationManager.applySettings();
                });

                this.dom.forceStrengthSlider.addEventListener('input', (e) => {
                    settings.forceStrength = parseFloat(e.target.value);
                    this.updateSliderDisplay('forceStrengthSlider', 'forceStrengthValue', settings.forceStrength);
                });

                this.dom.particleLifetimeSlider.addEventListener('input', (e) => {
                    settings.particleLifetime = parseFloat(e.target.value);
                    this.updateSliderDisplay('particleLifetimeSlider', 'particleLifetimeValue', settings.particleLifetime);
                    simulationManager.applySettings();
                });

                this.dom.frictionSlider.addEventListener('input', (e) => {
                    settings.friction = parseFloat(e.target.value);
                    this.updateSliderDisplay('frictionSlider', 'frictionValue', settings.friction);
                });

                this.dom.particleColorHueSlider.addEventListener('input', (e) => {
                    settings.particleColorHue = parseInt(e.target.value);
                    this.updateSliderDisplay('particleColorHueSlider', 'particleColorHueValue', settings.particleColorHue);
                    simulationManager.applySettings();
                });

                this.dom.randomColorSpectrumToggle.addEventListener('change', (e) => {
                    settings.randomColorSpectrumEnabled = e.target.checked;
                    simulationManager.applySettings();
                });

                this.dom.trailsToggle.addEventListener('change', (e) => {
                    settings.trails = e.target.checked;
                });

                this.dom.blendingModeSelect.addEventListener('change', (e) => {
                    settings.blendingMode = e.target.value;
                    simulationManager.applySettings();
                });

                this.dom.continuousSpawnToggle.addEventListener('change', (e) => {
                    settings.continuousSpawnEnabled = e.target.checked;
                });

                this.dom.continuousSpawnRateSlider.addEventListener('input', (e) => {
                    settings.continuousSpawnRate = parseFloat(e.target.value);
                    this.updateSliderDisplay('continuousSpawnRateSlider', 'continuousSpawnRateValue', settings.continuousSpawnRate);
                });

                this.dom.autoResetToggle.addEventListener('change', (e) => {
                    settings.autoResetEnabled = e.target.checked;
                    if (!settings.autoResetEnabled) {
                        simulationManager.timeSinceLastReset = 0;
                    }
                });

                this.dom.autoResetIntervalSlider.addEventListener('input', (e) => {
                    settings.autoResetInterval = parseFloat(e.target.value);
                    this.updateSliderDisplay('autoResetIntervalSlider', 'autoResetIntervalValue', settings.autoResetInterval);
                });

                this.dom.sceneSelect.addEventListener('change', (e) => {
                    simulationManager.loadScene(e.target.value);
                });

                this.dom.onScreenResetBtn.addEventListener('click', () => {
                    simulationManager.resetSimulation();
                    M.Tooltip.getInstance(this.dom.onScreenResetBtn).close();
                });

                this.dom.onScreenClearBtn.addEventListener('click', () => {
                    simulationManager.clearCanvas();
                    M.Tooltip.getInstance(this.dom.onScreenClearBtn).close();
                });
            },

            updateSliderDisplay(sliderId, valueSpanId, value) {
                const valueSpan = document.getElementById(valueSpanId);
                if (valueSpan) {
                    valueSpan.textContent = value;
                }
            },

            updateUIFromSettings() {
                const updateMaterializeSelect = (selectElement, value) => {
                    selectElement.value = value;
                    const instance = M.FormSelect.getInstance(selectElement);
                    if (instance) instance.destroy();
                    M.FormSelect.init(selectElement);
                };

                updateMaterializeSelect(this.dom.interactionModeSelect, settings.interactionMode);
                updateMaterializeSelect(this.dom.blendingModeSelect, settings.blendingMode);
                updateMaterializeSelect(this.dom.sceneSelect, 'default');

                this.dom.particleCountSlider.value = settings.maxParticles;
                this.updateSliderDisplay('particleCountSlider', 'particleCountValue', settings.maxParticles);

                this.dom.particleSizeSlider.value = settings.particleSize;
                this.updateSliderDisplay('particleSizeSlider', 'particleSizeValue', settings.particleSize);

                this.dom.particleSizeVarianceSlider.value = settings.particleSizeVariance;
                this.updateSliderDisplay('particleSizeVarianceSlider', 'particleSizeVarianceValue', settings.particleSizeVariance);

                this.dom.forceStrengthSlider.value = settings.forceStrength;
                this.updateSliderDisplay('forceStrengthSlider', 'forceStrengthValue', settings.forceStrength);

                this.dom.particleLifetimeSlider.value = settings.particleLifetime;
                this.updateSliderDisplay('particleLifetimeSlider', 'particleLifetimeValue', settings.particleLifetime);

                this.dom.frictionSlider.value = settings.friction;
                this.updateSliderDisplay('frictionSlider', 'frictionValue', settings.friction);

                this.dom.particleColorHueSlider.value = settings.particleColorHue;
                this.updateSliderDisplay('particleColorHueSlider', 'particleColorHueValue', settings.particleColorHue);

                this.dom.randomColorSpectrumToggle.checked = settings.randomColorSpectrumEnabled;
                this.dom.trailsToggle.checked = settings.trails;
                this.dom.continuousSpawnToggle.checked = settings.continuousSpawnEnabled;

                this.dom.continuousSpawnRateSlider.value = settings.continuousSpawnRate;
                this.updateSliderDisplay('continuousSpawnRateSlider', 'continuousSpawnRateValue', settings.continuousSpawnRate);

                this.dom.autoResetToggle.checked = settings.autoResetEnabled;
                this.dom.autoResetIntervalSlider.value = settings.autoResetInterval;
                this.updateSliderDisplay('autoResetIntervalSlider', 'autoResetIntervalValue', settings.autoResetInterval);

                this.updateHUD(0, 0, settings.interactionMode);
            },

            updateHUD(particleCount, fps, interactionMode) {
                if (this.dom.currentParticleCountSpan) this.dom.currentParticleCountSpan.textContent = particleCount;
                if (this.dom.fpsDisplaySpan) this.dom.fpsDisplaySpan.textContent = fps;
                if (this.dom.currentInteractionModeSpan) this.dom.currentInteractionModeSpan.textContent = interactionMode.charAt(0).toUpperCase() + interactionMode.slice(1);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('particleCanvas');
            const simulationManager = new SimulationManager(canvas);

            UIManager.init();
            UIManager.bindEventListeners(simulationManager);
            simulationManager.init();
            UIManager.updateUIFromSettings();
        });
    </script>

<!-- Injectable Console Log Copier Snippet -->
<div id="appgen2025ConsoleCopyUtil" style="position: fixed; top: 5px; right: 5px; z-index: 9999; padding: 5px; background-color: rgba(0,0,0,0.7); border-radius: 5px; cursor: default;" title="Copy Console Logs for this Tab">
    <button type="button" style="background: none; border: 1px solid #fff; color: #fff; padding: 3px 8px; font-size: 10px; border-radius: 3px; cursor: pointer;">Copy Logs</button>
</div>
<script>
    (function() {
        const utilContainer = document.getElementById('appgen2025ConsoleCopyUtil');
        if (utilContainer) {
            const originalConsoleLog = console.log; const originalConsoleError = console.error; const originalConsoleWarn = console.warn; const originalConsoleInfo = console.info; const originalConsoleDebug = console.debug;
            const logs = [];
            function formatLog(type, args) {
                const timestamp = new Date().toISOString();
                const message = Array.from(args).map(arg => { try { if (arg instanceof Error) return arg.stack || arg.toString(); if (typeof arg === 'object' && arg !== null) { const getCircularReplacer = () => { const seen = new WeakSet(); return (key, value) => { if (typeof value === "object" && value !== null) { if (seen.has(value)) { return "[Circular]"; } seen.add(value); } return value; }; }; return JSON.stringify(arg, getCircularReplacer(), 2); } return String(arg); } catch (e) { return '[Unserializable Object]'; } }).join(' ');
                return `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            }
            console.log = function(...args) { const formatted = formatLog('log', args); logs.push(formatted); originalConsoleLog.apply(console, args); };
            console.error = function(...args) { const formatted = formatLog('error', args); logs.push(formatted); originalConsoleError.apply(console, args); };
            console.warn = function(...args) { const formatted = formatLog('warn', args); logs.push(formatted); originalConsoleWarn.apply(console, args); };
            console.info = function(...args) { const formatted = formatLog('info', args); logs.push(formatted); originalConsoleInfo.apply(console, args); };
            console.debug = function(...args) { const formatted = formatLog('debug', args); logs.push(formatted); originalConsoleDebug.apply(console, args); };
            window.onerror = function(message, source, lineno, colno, error) { const errorObj = error || {}; const formatted = formatLog('uncaught_error', [message, `at ${source}:${lineno}:${colno}`, errorObj.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Uncaught Error:', message, 'at', source + ':' + lineno + ':' + colno, error); return false; };
            window.onunhandledrejection = function(event) { const reason = event.reason || {}; const formatted = formatLog('unhandled_rejection', [reason.message || reason, reason.stack || '(no stack)']); logs.push(formatted); originalConsoleError.call(console, 'Unhandled Rejection:', event.reason); };
            const copyButton = utilContainer.querySelector('button');
            if (copyButton) {
                copyButton.addEventListener('click', function(e) {
                    e.stopPropagation(); if (logs.length === 0) { alert('No console logs captured yet to copy.'); return; }
                    const logText = logs.join('\n');
                    navigator.clipboard.writeText(logText).then(function() {
                        const originalText = copyButton.textContent; copyButton.textContent = 'Copied!'; copyButton.style.background = '#28a745'; copyButton.style.borderColor = '#28a745';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 2000);
                        originalConsoleInfo.call(console, 'AppGen2025 Util: Console logs copied to clipboard.');
                    }).catch(function(err) {
                        originalConsoleError.call(console, 'AppGen2025 Util: Failed to copy console logs - ', err.name, err.message);
                        alert('Failed to copy logs. See browser console for details. Logs may be too large or permissions denied.');
                        const originalText = copyButton.textContent; copyButton.textContent = 'Failed!'; copyButton.style.background = '#dc3545'; copyButton.style.borderColor = '#dc3545';
                        setTimeout(function() { copyButton.textContent = originalText; copyButton.style.background = 'none'; copyButton.style.borderColor = '#fff'; }, 3000);
                    });
                });
            }
        } else { console.error('AppGen2025 Util: Container element "appgen2025ConsoleCopyUtil" not found.'); }
    })();
</script>
<!-- End of Injectable Snippet -->

</body>
</html>